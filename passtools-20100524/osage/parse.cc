/*
 * Copyright 2006, 2007
 *	The President and Fellows of Harvard College.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdarg.h>
#include <stdlib.h>
#include "ptnode.h"

/*
 * AnaGram, A System for Syntax Directed Programming
 * File generated by: Snap 2.40-20070527   Jun  1 2007
 *
 * AnaGram Parsing Engine
 * Copyright 1993-2002 Parsifal Software. All Rights Reserved.
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

#ifndef PARSE_H_1182556825
#include "parse.h"
#endif

#ifndef PARSE_H_1182556825
#error Mismatched header file
#endif

#include <ctype.h>
#include <stdio.h>

#define RULE_CONTEXT (&((PCB).cs[(PCB).ssx]))
#define ERROR_CONTEXT ((PCB).cs[(PCB).error_frame_ssx])
#define CONTEXT ((PCB).cs[(PCB).ssx])



parse_pcb_type parse_pcb;
#define PCB parse_pcb

#line 270 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
static ptnode *results;
static char stringbuf[4096];
static size_t stringbufpos;

#define SYNTAX_ERROR          \
	whine(parser_whereis(), "%s", PCB.error_message)
#define REDUCTION_TOKEN_ERROR \
	die(parser_whereis(), "Internal error: bad reduction token")
#define PARSE_STACK_OVERFLOW  \
	die(parser_whereis(), "Parse stack overflow")

location parser_whereis(void) {
   location loc;
   loc.line = PCB.line;
   loc.col = PCB.column;
   return loc;
}

static char *addstring(char *s, int ch) {
   if (stringbufpos >= sizeof(stringbuf)-1) {
      die(parser_whereis(), "String or identifier too long");
   }
   stringbuf[stringbufpos++] = ch;
   stringbuf[stringbufpos] = 0;
   return s;
}

static char *startstring(int ch) {
   stringbufpos = 0;
   return addstring(stringbuf, ch);
}

static char *emptystring(void) {
   stringbufpos = 0;
   stringbuf[stringbufpos] = 0;
   return stringbuf;
}

ptnode *parse_file(const char *path) {
   FILE *f;
   int ch;

   f = fopen(path, "r");
   if (!f) {
      fprintf(stderr, "%s: Open failed\n", path);
      return NULL;
   }

   init_parse();
   while ((ch = getc(f))!=EOF) {
      PCB.input_code = ch;
      parse();
      if (PCB.exit_flag!=AG_RUNNING_CODE && PCB.exit_flag!=AG_SUCCESS_CODE) {
         return NULL;
      }
   }
   PCB.input_code = 0;
   parse();
   if (PCB.exit_flag != AG_SUCCESS_CODE) {
      return NULL;
   }

   ptnode *ret = results;
   results = NULL;
   return ret;
}

ptnode *parse_string(const char *string) {

   init_parse();
   while (*string) {
      PCB.input_code = (unsigned char) *(string++);
      parse();
      if (PCB.exit_flag!=AG_RUNNING_CODE && PCB.exit_flag!=AG_SUCCESS_CODE) {
         return NULL;
      }
   }
   PCB.input_code = 0;
   parse();
   if (PCB.exit_flag != AG_SUCCESS_CODE) {
      return NULL;
   }

   ptnode *ret = results;
   results = NULL;
   return ret;
}

#line 168 "parse.cc"

#ifndef CONVERT_CASE
#define CONVERT_CASE(c) (c)
#endif
#ifndef TAB_SPACING
#define TAB_SPACING 8
#endif

static void ag_rp_1(ptnode * e) {
#line 48 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  results = e;
#line 180 "parse.cc"
}

static ptnode * ag_rp_2(ptnode * h, ptnode * e) {
#line 56 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_scope(h,e);
#line 186 "parse.cc"
}

static ptnode * ag_rp_3(ptnode * h, ptnode * e) {
#line 57 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_scope(h,e);
#line 192 "parse.cc"
}

static ptnode * ag_rp_4(ptnode * h, ptnode * e) {
#line 61 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_scope(h,e);
#line 198 "parse.cc"
}

static ptnode * ag_rp_5(ptnode * b, ptnode * g) {
#line 64 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_forbind(b,g);
#line 204 "parse.cc"
}

static ptnode * ag_rp_6(ptnode * b, ptnode * g) {
#line 67 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_letbind(b,g);
#line 210 "parse.cc"
}

static ptnode * ag_rp_7(char * s) {
#line 70 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_lambda(pt_varname(s));
#line 216 "parse.cc"
}

static ptnode * ag_rp_8(char * s) {
#line 74 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_varname(s);
#line 222 "parse.cc"
}

static ptnode * ag_rp_9(ptnode * e, ptnode * f) {
#line 78 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_filter(e,f);
#line 228 "parse.cc"
}

static ptnode * ag_rp_10(ptnode * n) {
#line 81 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_tuple(n);
#line 234 "parse.cc"
}

static ptnode * ag_rp_11(ptnode * n) {
#line 84 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_mklist(n);
#line 240 "parse.cc"
}

static ptnode * ag_rp_12(ptnode * ns, ptnode * n) {
#line 85 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_addlist(ns,n);
#line 246 "parse.cc"
}

static ptnode * ag_rp_13(ptnode * n) {
#line 88 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return n;
#line 252 "parse.cc"
}

static ptnode * ag_rp_14(ptnode * n, ptnode * m) {
#line 90 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(n,OP_PATH,m);
#line 258 "parse.cc"
}

static ptnode * ag_rp_15(ptnode * n, ptnode * m) {
#line 91 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(n,OP_LONGPATHZ,m);
#line 264 "parse.cc"
}

static ptnode * ag_rp_16(ptnode * n, ptnode * m) {
#line 92 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(n,OP_LONGPATHNZ,m);
#line 270 "parse.cc"
}

static ptnode * ag_rp_17(ptnode * n) {
#line 95 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return n;
#line 276 "parse.cc"
}

static ptnode * ag_rp_18(ptnode * n) {
#line 96 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_uop(OP_OPTIONAL, n);
#line 282 "parse.cc"
}

static ptnode * ag_rp_19(ptnode * n) {
#line 128 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return n;
#line 288 "parse.cc"
}

static ptnode * ag_rp_20(ptnode * n) {
#line 129 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_uop(OP_EXTRACT, n);
#line 294 "parse.cc"
}

static ptnode * ag_rp_21(ptnode * l, ptnode * r) {
#line 150 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l, OP_LOGAND, r);
#line 300 "parse.cc"
}

static ptnode * ag_rp_22(ptnode * l, ptnode * r) {
#line 151 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l, OP_LOGOR, r);
#line 306 "parse.cc"
}

static ptnode * ag_rp_23(ptnode * l, ptnode * r) {
#line 155 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l, OP_EQ, r);
#line 312 "parse.cc"
}

static ptnode * ag_rp_24(ptnode * l, ptnode * r) {
#line 156 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l, OP_NE, r);
#line 318 "parse.cc"
}

static ptnode * ag_rp_25(ptnode * l, ptnode * r) {
#line 160 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_MATCH,r);
#line 324 "parse.cc"
}

static ptnode * ag_rp_26(ptnode * l, ptnode * r) {
#line 161 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_NOMATCH,r);
#line 330 "parse.cc"
}

static ptnode * ag_rp_27(ptnode * l, ptnode * r) {
#line 162 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_LT,r);
#line 336 "parse.cc"
}

static ptnode * ag_rp_28(ptnode * l, ptnode * r) {
#line 163 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_GT,r);
#line 342 "parse.cc"
}

static ptnode * ag_rp_29(ptnode * l, ptnode * r) {
#line 164 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_LE,r);
#line 348 "parse.cc"
}

static ptnode * ag_rp_30(ptnode * l, ptnode * r) {
#line 165 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_GE,r);
#line 354 "parse.cc"
}

static ptnode * ag_rp_31(ptnode * l, ptnode * r) {
#line 166 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_CONTAINS,r);
#line 360 "parse.cc"
}

static ptnode * ag_rp_32(ptnode * l, ptnode * r) {
#line 170 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_CONS,r);
#line 366 "parse.cc"
}

static ptnode * ag_rp_33(ptnode * a, char * b) {
#line 171 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_range(a, pt_number(b));
#line 372 "parse.cc"
}

static ptnode * ag_rp_34(char * a) {
#line 175 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_number(a);
#line 378 "parse.cc"
}

static ptnode * ag_rp_35(ptnode * l, ptnode * r) {
#line 179 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_ADD,r);
#line 384 "parse.cc"
}

static ptnode * ag_rp_36(ptnode * l, ptnode * r) {
#line 180 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_SUB,r);
#line 390 "parse.cc"
}

static ptnode * ag_rp_37(ptnode * l, ptnode * r) {
#line 181 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_STRCAT,r);
#line 396 "parse.cc"
}

static ptnode * ag_rp_38(ptnode * l, ptnode * r) {
#line 185 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_MUL,r);
#line 402 "parse.cc"
}

static ptnode * ag_rp_39(ptnode * l, ptnode * r) {
#line 186 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_DIV,r);
#line 408 "parse.cc"
}

static ptnode * ag_rp_40(ptnode * l, ptnode * r) {
#line 187 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_bop(l,OP_MOD,r);
#line 414 "parse.cc"
}

static ptnode * ag_rp_41(ptnode * e, char * x) {
#line 191 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_fieldref(e,x);
#line 420 "parse.cc"
}

static ptnode * ag_rp_42(ptnode * x, ptnode * e) {
#line 192 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_func(x,e);
#line 426 "parse.cc"
}

static ptnode * ag_rp_43(ptnode * e) {
#line 196 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_uop(OP_NEG,e);
#line 432 "parse.cc"
}

static ptnode * ag_rp_44(ptnode * e) {
#line 197 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_uop(OP_LOGNOT,e);
#line 438 "parse.cc"
}

static ptnode * ag_rp_45(char * s) {
#line 200 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_varname(s);
#line 444 "parse.cc"
}

static ptnode * ag_rp_46(char * s) {
#line 201 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_string(s);
#line 450 "parse.cc"
}

static ptnode * ag_rp_47(char * n) {
#line 202 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_number(n);
#line 456 "parse.cc"
}

static ptnode * ag_rp_48(char * x) {
#line 203 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_field(x);
#line 462 "parse.cc"
}

static ptnode * ag_rp_49(void) {
#line 204 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_all();
#line 468 "parse.cc"
}

static ptnode * ag_rp_50(ptnode * e) {
#line 205 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return e;
#line 474 "parse.cc"
}

static ptnode * ag_rp_51(ptnode * e) {
#line 206 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_scope(pt_lambda(pt_varname("this")), e);
#line 480 "parse.cc"
}

static ptnode * ag_rp_52(ptnode * e) {
#line 207 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_listconstant(e);
#line 486 "parse.cc"
}

static ptnode * ag_rp_53(void) {
#line 208 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_tuple(NULL);
#line 492 "parse.cc"
}

static ptnode * ag_rp_54(void) {
#line 209 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return pt_listconstant(NULL);
#line 498 "parse.cc"
}

static char * ag_rp_55(char * s) {
#line 232 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return s;
#line 504 "parse.cc"
}

static char * ag_rp_56(void) {
#line 235 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return emptystring();
#line 510 "parse.cc"
}

static char * ag_rp_57(char * s, int c) {
#line 236 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return addstring(s,c);
#line 516 "parse.cc"
}

static int ag_rp_58(int c) {
#line 239 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return c;
#line 522 "parse.cc"
}

static int ag_rp_59(void) {
#line 240 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return '\\';
#line 528 "parse.cc"
}

static int ag_rp_60(void) {
#line 241 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return '"';
#line 534 "parse.cc"
}

static int ag_rp_61(void) {
#line 242 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return '\n';
#line 540 "parse.cc"
}

static int ag_rp_62(void) {
#line 243 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return '\t';
#line 546 "parse.cc"
}

static int ag_rp_63(int a, int b) {
#line 244 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return a*16+b;
#line 552 "parse.cc"
}

static char * ag_rp_64(int c) {
#line 247 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return startstring(c);
#line 558 "parse.cc"
}

static char * ag_rp_65(char * s, int c) {
#line 248 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return addstring(s,c);
#line 564 "parse.cc"
}

static char * ag_rp_66(int c) {
#line 251 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return startstring(c);
#line 570 "parse.cc"
}

static char * ag_rp_67(char * s, int c) {
#line 252 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return addstring(s,c);
#line 576 "parse.cc"
}

static int ag_rp_68(int c) {
#line 255 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return c-'a'+10;
#line 582 "parse.cc"
}

static int ag_rp_69(int c) {
#line 256 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return c-'A'+10;
#line 588 "parse.cc"
}

static int ag_rp_70(int c) {
#line 257 "/home/nastar/dholland/projects/prov/tools/passtools/sage/parse.syn"
  return c-'0';
#line 594 "parse.cc"
}


#define READ_COUNTS 
#define WRITE_COUNTS 
#undef V
#define V(i,t) (*t (&(PCB).vs[(PCB).ssx + i]))
#undef VS
#define VS(i) (PCB).vs[(PCB).ssx + i]

#ifndef GET_CONTEXT
#define GET_CONTEXT CONTEXT = (PCB).input_context
#endif

typedef enum {
  ag_action_1,
  ag_action_2,
  ag_action_3,
  ag_action_4,
  ag_action_5,
  ag_action_6,
  ag_action_7,
  ag_action_8,
  ag_action_9,
  ag_action_10,
  ag_action_11,
  ag_action_12
} ag_parser_action;


#ifndef NULL_VALUE_INITIALIZER
#define NULL_VALUE_INITIALIZER = { 0 }
#endif

static parse_vs_type const ag_null_value NULL_VALUE_INITIALIZER;

static const unsigned char ag_rpx[] = {
    0,  0,  0,  0,  0,  1,  0,  0,  0,  2,  3,  4,  5,  6,  7,  8,  0,  9,
   10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,  0,  0, 21, 22,  0, 23, 24,
    0, 25, 26, 27, 28, 29, 30, 31,  0, 32, 33, 34,  0, 35, 36, 37,  0, 38,
   39, 40,  0, 41, 42,  0, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
   55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70
};

static const unsigned char ag_key_itt[] = {
 0
};

static const unsigned short ag_key_pt[] = {
0
};

static const unsigned char ag_key_ch[] = {
    0, 91, 93,255, 40, 42, 91,102,108,255, 61,126,255, 42, 43,255, 62,255,
   61,255, 91, 93,255, 33, 38, 40, 42, 43, 45, 60, 61, 62, 91, 93, 99,102,
  105,108,116,119,124,255, 61,126,255, 42, 43,255, 62,255, 33, 38, 43, 45,
   60, 61, 62, 93, 99,105,119,124,255, 91, 93,255, 40, 42, 91,255, 61,126,
  255, 42, 43,255, 62,255, 33, 38, 45, 60, 61, 62, 93, 99,105,119,124,255,
   42, 43,255, 62,255, 33, 38, 45, 61, 93,105,119,124,255, 42, 43,255, 62,
  255, 38, 45, 93,105,119,124,255, 42, 43,255, 62,255, 45, 93,105,119,255,
   93,105,119,255,105,255, 61,126,255, 42, 43,255, 62,255, 33, 38, 43, 45,
   60, 61, 62, 93, 99,105,116,119,124,255, 93,255, 61,255, 93,105,255
};

static const unsigned char ag_key_act[] = {
  0,0,0,4,3,3,2,3,3,4,0,0,4,0,0,4,1,4,0,4,0,0,4,2,3,3,3,3,2,3,1,3,2,3,3,
  3,3,3,3,3,3,4,0,0,4,0,0,4,1,4,2,3,3,2,3,3,3,3,3,3,3,3,4,0,0,4,3,3,2,4,
  0,0,4,0,0,4,1,4,2,3,2,3,3,3,3,3,3,3,3,4,0,0,4,1,4,3,3,2,3,3,3,3,3,4,0,
  0,4,1,4,3,2,3,3,3,3,4,0,0,4,1,4,2,3,3,3,4,3,3,3,4,3,4,0,0,4,0,0,4,1,4,
  2,3,3,2,3,3,3,3,3,3,3,3,3,4,3,4,0,4,3,3,4
};

static const unsigned char ag_key_parm[] = {
    0, 74, 77,  0, 76, 71,  0,  2,  3,  0, 43, 46,  0, 31, 32,  0, 30,  0,
   42,  0, 74, 77,  0,  0, 39, 76, 71, 59,  0, 49, 24, 50,  0, 75,  1,  2,
    5,  3, 55,  4, 40,  0, 43, 46,  0, 31, 32,  0, 30,  0,  0, 39, 59,  0,
   49, 42, 50, 75,  1,  5,  4, 40,  0, 74, 77,  0, 76, 71,  0,  0, 43, 46,
    0, 31, 32,  0, 30,  0,  0, 39,  0, 49, 42, 50, 75,  1,  5,  4, 40,  0,
   31, 32,  0, 30,  0, 43, 39,  0, 42, 75,  5,  4, 40,  0, 31, 32,  0, 30,
    0, 39,  0, 75,  5,  4, 40,  0, 31, 32,  0, 30,  0,  0, 75,  5,  4,  0,
   75,  5,  4,  0,  5,  0, 43, 46,  0, 31, 32,  0, 30,  0,  0, 39, 59,  0,
   49, 42, 50, 75,  1,  5, 55,  4, 40,  0, 75,  0, 24,  0, 75,  5,  0
};

static const unsigned char ag_key_jmp[] = {
    0,  0,  0,  0,  0,  2,  1,  4,  7,  0,  0,  0,  0,  0,  0,  0, 13,  0,
    0,  0,  0,  0,  0, 10, 10, 12, 14, 16, 16, 18, 18, 20, 20, 22, 24, 32,
   35, 37, 40, 42, 47,  0,  0,  0,  0,  0,  0,  0, 45,  0, 42, 49, 51, 48,
   53, 55, 57, 59, 61, 69, 71, 76,  0,  0,  0,  0, 78, 80, 63,  0,  0,  0,
    0,  0,  0,  0, 73,  0, 70, 82, 76, 84, 86, 88, 90, 92,100,102,107,  0,
    0,  0,  0, 90,  0,109,111, 93,113,115,117,119,124,  0,  0,  0,  0,104,
    0,126,107,128,130,132,137,  0,  0,  0,  0,116,  0,119,139,141,143,  0,
  148,150,152,  0,157,  0,  0,  0,  0,  0,  0,  0,135,  0,132,159,161,138,
  163,165,167,169,171,179,181,183,188,  0,190,  0,  0,  0,192,194,  0
};

static const unsigned char ag_key_index[] = {
    4, 23,  4,  0,  4,  4,  4, 50,  0, 50, 50, 66, 66, 50, 50, 50,  0, 50,
   78, 78, 95,109,121,121,121,126,  0,  0,  0,126,  0,130,130,  0,  0,  4,
    4,  4, 50, 50, 66,  0,140, 66, 66, 66, 78, 66, 66, 66, 66, 66, 66, 66,
   66, 66, 66, 66, 66, 66, 66, 66,121, 66, 66, 66, 66,  0,  0,  0,  0,  4,
    4,  4,  0,  0,  0,154,  0,  0, 66, 50,  0, 66, 66, 66, 66, 66, 66, 50,
   66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66,  0,156,  4,
    4,  4,  4,  4,  4,  0, 50, 50, 50,  0, 50, 50, 50, 50, 50, 50, 78, 78,
   78, 78, 78, 78, 78, 78, 78, 95, 95,121,156,  0,  0, 50,  4,158,  0,  0
};

static const unsigned char ag_key_ends[] = {
41,0, 42,0, 111,114,0, 101,116,0, 38,0, 41,0, 42,0, 43,0, 
61,0, 61,0, 93,0, 111,110,116,97,105,110,115,0, 111,114,0, 110,0, 
101,116,0, 111,0, 104,101,114,101,0, 124,0, 38,0, 43,0, 61,0, 
61,0, 61,0, 93,0, 111,110,116,97,105,110,115,0, 110,0, 
104,101,114,101,0, 124,0, 41,0, 42,0, 38,0, 61,0, 61,0, 61,0, 
93,0, 111,110,116,97,105,110,115,0, 110,0, 104,101,114,101,0, 
124,0, 61,0, 38,0, 61,0, 93,0, 110,0, 104,101,114,101,0, 124,0, 
38,0, 93,0, 110,0, 104,101,114,101,0, 124,0, 93,0, 110,0, 
104,101,114,101,0, 93,0, 110,0, 104,101,114,101,0, 110,0, 38,0, 
43,0, 61,0, 61,0, 61,0, 93,0, 111,110,116,97,105,110,115,0, 
110,0, 111,0, 104,101,114,101,0, 124,0, 93,0, 93,0, 110,0, 
};
#define AG_TCV(x) (((int)(x) >= 0 && (int)(x) <= 255) ? ag_tcv[(x)] : 0)

static const unsigned char ag_tcv[] = {
   12,  0,  0,  0,  0,  0,  0,  0,  0, 90, 90,  0,  0, 90,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 90, 36, 78, 92,
   92, 63, 92, 92, 66, 67, 61, 57, 28, 58, 65, 62, 87, 87, 87, 87, 87, 87,
   87, 87, 87, 87, 52, 10, 47, 92, 48, 34, 70, 89, 89, 89, 89, 89, 89, 93,
   93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
   93, 72, 22, 73, 92, 93, 92, 88, 88, 88, 88, 88, 88, 93, 93, 93, 93, 93,
   93, 93, 82, 93, 93, 93, 93, 93, 83, 93, 93, 93, 93, 93, 93, 19, 92, 20,
   45,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0
};

#ifndef SYNTAX_ERROR
#define SYNTAX_ERROR fprintf(stderr,"%s, line %d, column %d\n", \
  (PCB).error_message, (PCB).line, (PCB).column)
#endif

#ifndef FIRST_LINE
#define FIRST_LINE 1
#endif

#ifndef FIRST_COLUMN
#define FIRST_COLUMN 1
#endif

#ifndef PARSER_STACK_OVERFLOW
#define PARSER_STACK_OVERFLOW {fprintf(stderr, \
   "\nParser stack overflow, line %d, column %d\n",\
   (PCB).line, (PCB).column);}
#endif

#ifndef REDUCTION_TOKEN_ERROR
#define REDUCTION_TOKEN_ERROR {fprintf(stderr, \
    "\nReduction token error, line %d, column %d\n", \
    (PCB).line, (PCB).column);}
#endif


typedef enum
  {ag_accept_key, ag_set_key, ag_jmp_key, ag_end_key, ag_no_match_key,
   ag_cf_accept_key, ag_cf_set_key, ag_cf_end_key} key_words;


#ifndef AG_NEWLINE
#define AG_NEWLINE 10
#endif

#ifndef AG_RETURN
#define AG_RETURN 13
#endif

#ifndef AG_FORMFEED
#define AG_FORMFEED 12
#endif

#ifndef AG_TABCHAR
#define AG_TABCHAR 9
#endif

static void ag_track(void) {
  int ag_k = 0;
  while (ag_k < (PCB).rx) {
    int ag_ch = (PCB).lab[ag_k++];
    switch (ag_ch) {
    case AG_NEWLINE:
      (PCB).column = 1, (PCB).line++;
    case AG_RETURN:
    case AG_FORMFEED:
      break;
    case AG_TABCHAR:
      (PCB).column += (TAB_SPACING) - ((PCB).column - 1) % (TAB_SPACING);
      break;
    default:
      (PCB).column++;
    }
  }
  ag_k = 0;
  while ((PCB).rx < (PCB).fx) (PCB).lab[ag_k++] = (PCB).lab[(PCB).rx++];
  (PCB).fx = ag_k;
  (PCB).rx = 0;
}


static void ag_prot(void) {
  int ag_k;
  ag_k = 128 - ++(PCB).btsx;
  if (ag_k <= (PCB).ssx) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
    return;
  }
  (PCB).bts[(PCB).btsx] = (PCB).sn;
  (PCB).bts[ag_k] = (PCB).ssx;
  (PCB).vs[ag_k] = (PCB).vs[(PCB).ssx];
  (PCB).ss[ag_k] = (PCB).ss[(PCB).ssx];
}

static void ag_undo(void) {
  if ((PCB).drt == -1) return;
  while ((PCB).btsx) {
    int ag_k = 128 - (PCB).btsx;
    (PCB).sn = (PCB).bts[(PCB).btsx--];
    (PCB).ssx = (PCB).bts[ag_k];
    (PCB).vs[(PCB).ssx] = (PCB).vs[ag_k];
    (PCB).ss[(PCB).ssx] = (PCB).ss[ag_k];
  }
  (PCB).token_number = (parse_token_type) (PCB).drt;
  (PCB).ssx = (PCB).dssx;
  (PCB).sn = (PCB).dsn;
  (PCB).drt = -1;
}


static const unsigned char ag_tstt[] = {
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,6,7,8,91,
90,0,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,92,90,89,88,87,83,82,78,73,72,70,67,66,65,63,62,61,58,57,52,48,47,45,36,
  34,28,22,20,19,10,0,79,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,89,88,83,82,0,23,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,90,89,88,87,83,82,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,
  43,42,40,39,36,34,32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,64,68,69,
66,65,0,
93,90,89,88,87,83,82,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,
  43,42,40,39,36,34,32,31,30,28,20,12,10,5,4,1,0,7,8,91,
63,62,61,0,
87,0,54,
59,58,57,0,
52,0,
50,49,48,47,46,45,1,0,
43,42,0,
40,39,0,
36,0,
34,0,
32,31,30,0,
28,0,
93,90,89,88,83,82,0,7,8,91,
90,0,7,91,
90,0,7,91,
4,0,
19,0,
5,0,
5,0,
12,10,0,11,
93,92,90,89,88,87,83,82,78,73,72,70,67,66,65,63,62,61,58,57,52,48,47,45,36,
  34,28,22,20,19,10,0,80,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,90,89,88,87,83,82,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,
  43,42,40,39,36,34,32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,90,89,88,87,83,82,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,
  43,42,40,39,36,34,32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,89,88,83,82,0,23,
55,0,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,75,73,67,52,50,49,48,47,46,45,43,42,40,39,36,34,32,31,
  30,28,20,12,10,5,4,1,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,51,54,56,60,64,68,69,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
90,75,73,67,34,32,31,30,28,20,12,10,5,4,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,7,8,91,
93,89,88,83,82,0,23,
93,89,88,83,82,0,21,23,
93,89,88,83,82,0,21,23,
90,0,7,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
90,12,0,7,8,91,
12,0,
83,82,78,66,22,0,
75,0,
73,0,
67,0,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,25,26,27,29,33,35,37,
  38,41,44,51,53,54,56,60,64,68,69,
93,90,89,88,87,83,82,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,
  43,42,40,39,36,34,32,31,30,28,20,12,10,5,4,1,0,7,8,91,
90,0,7,91,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,54,56,60,64,68,69,
59,58,57,0,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,44,51,53,54,56,60,64,
  68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,41,44,51,53,54,56,60,
  64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,41,44,51,53,54,56,60,
  64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,38,41,44,51,53,54,56,
  60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,38,41,44,51,53,54,56,
  60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,29,33,35,37,38,41,44,
  51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,29,33,35,37,38,41,44,
  51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,29,33,35,37,38,41,44,
  51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,0,23,27,29,33,35,37,38,41,
  44,51,53,54,56,60,64,68,69,
93,90,89,88,87,83,82,19,0,7,8,91,
93,90,89,88,87,83,82,24,0,7,8,91,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
93,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,9,13,14,15,16,17,
  18,23,25,26,27,29,33,35,37,38,41,44,51,53,54,56,60,64,68,69,
89,88,87,0,84,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
67,0,
66,65,0,
66,65,0,
66,65,0,
63,62,61,0,
63,62,61,0,
63,62,61,0,
52,0,
52,0,
52,0,
52,0,
52,0,
52,0,
52,0,
50,49,48,47,46,45,1,0,
50,49,48,47,46,45,1,0,
43,42,0,
43,42,0,
32,31,30,0,
24,0,
20,0,
89,88,87,0,84,
90,75,73,67,66,65,63,62,61,59,58,57,52,50,49,48,47,46,45,43,42,40,39,36,34,
  32,31,30,28,20,12,10,5,4,1,0,7,8,91,
93,90,89,88,87,83,82,78,77,76,74,72,71,70,66,58,36,22,3,2,0,7,8,91,
90,75,73,67,20,12,10,5,0,7,8,91,
67,0,
  0
};


static unsigned const char ag_astt[2636] = {
  8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,0,1,1,1,9,5,2,2,2,2,2,2,1,2,2,1,
  1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,7,1,8,1,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,1,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,2,2,2,2,2,
  7,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  7,2,2,1,10,1,10,10,10,10,10,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,2,2,1,
  2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,2,2,1,1,1,5,10,1,10,10,10,10,10,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,1,2,1,1,
  1,1,5,2,7,1,1,1,1,5,1,5,1,1,1,1,1,1,1,5,1,1,5,1,1,5,1,4,2,4,1,1,1,4,1,4,8,
  1,8,8,8,8,7,1,1,1,1,7,1,1,1,7,1,1,1,5,1,7,1,7,1,7,8,1,7,1,2,2,2,2,2,2,2,2,
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,7,2,2,2,2,2,2,2,1,2,2,1,1,1,
  1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,
  2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,
  2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,10,1,10,10,10,10,10,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,10,1,10,10,10,10,10,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,
  8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,2,2,2,2,2,7,1,1,5,8,1,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,10,1,10,10,10,10,10,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,7,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,8,
  1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,
  1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,7,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,8,1,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,2,
  2,2,2,2,7,1,2,2,2,2,2,7,1,1,2,2,2,2,2,7,1,1,1,7,1,1,8,1,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,7,1,1,1,8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,
  8,1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,7,1,1,1,1,5,7,3,3,1,2,7,2,2,2,1,2,
  7,1,7,1,7,1,7,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,2,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,10,1,10,10,10,10,10,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,1,7,2,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,
  7,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,2,2,2,2,2,2,1,
  2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,
  1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,
  1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,4,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,
  1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,2,2,
  2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,
  1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,
  1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,
  2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,
  1,7,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,
  1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,
  2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,
  1,1,1,1,7,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,
  7,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,2,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,7,1,1,2,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,10,1,10,10,10,10,10,5,7,2,2,1,10,1,10,10,10,10,10,8,7,
  1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,2,2,2,2,1,1,1,1,1,1,1,2,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,2,2,2,2,1,
  1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,
  1,1,1,7,2,2,2,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,
  2,2,1,1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,2,2,2,2,1,1,1,1,1,1,1,2,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,7,2,2,2,2,1,1,
  1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,7,1,1,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,1,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,1,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,1,7,1,1,4,1,
  1,4,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,1,1,1,1,1,
  1,4,1,1,1,1,1,1,1,4,1,1,4,1,1,4,1,1,1,4,1,7,1,7,2,2,2,7,1,1,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,5,1,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,2,2,1,1,5,5,5,5,5,5,5,7,2,2,1,2,7,11
};


static const unsigned char ag_pstt[] = {
2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,
89,90,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,2,33,33,33,33,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,
  73,73,73,73,73,73,3,34,
35,1,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,4,35,35,1,
36,1,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,5,36,36,1,
37,1,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,6,37,37,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,66,
  66,1,
81,81,81,81,81,8,38,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,63,
  63,1,
82,1,82,82,82,82,82,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,10,62,62,1,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,11,10,39,61,61,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,12,10,39,60,60,9,
40,41,52,
84,1,84,84,84,84,84,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,14,42,64,1,
43,44,45,48,
83,16,46,
47,48,49,44,
50,36,
52,53,54,55,56,57,51,33,
58,59,30,
60,61,29,
62,27,
26,25,
63,64,65,19,
66,18,
67,1,67,67,67,67,26,67,67,1,
1,27,68,1,
1,28,69,1,
70,16,
71,30,
72,31,
73,32,
75,74,33,75,
75,75,75,75,75,75,75,75,72,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,
  75,75,76,75,75,75,34,74,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,35,77,77,77,77,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,36,78,78,78,78,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,37,79,79,79,79,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
82,1,82,82,82,82,82,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,38,65,65,1,
84,1,84,84,84,84,84,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,39,64,64,1,
80,1,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,40,80,80,1,
81,81,81,81,81,41,81,
82,2,
83,1,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,43,83,83,1,
84,1,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,44,84,84,1,
85,1,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,45,85,85,1,
84,1,84,84,84,84,84,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,46,
  46,46,1,
86,1,86,86,86,86,86,86,86,86,86,86,86,86,86,86,86,47,86,86,1,
87,1,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,48,87,87,1,
88,1,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,49,88,88,1,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,50,10,89,39,15,13,13,13,9,
90,1,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,51,90,90,1,
91,1,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,52,91,91,1,
92,1,92,92,92,92,92,92,92,92,92,92,92,92,92,92,92,53,92,92,1,
93,1,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,54,93,93,1,
94,1,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,55,94,94,1,
95,1,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,56,95,95,1,
96,1,96,96,96,96,96,96,96,96,96,96,96,96,96,96,96,57,96,96,1,
97,1,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,58,97,97,1,
98,1,98,98,98,98,98,98,98,98,98,98,98,98,98,98,98,59,98,98,1,
99,1,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,60,99,99,1,
100,1,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,61,100,
  100,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,62,28,28,1,
101,1,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,63,101,
  101,1,
102,1,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,64,102,
  102,1,
103,1,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,65,103,
  103,1,
104,1,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,66,104,
  104,1,
81,81,81,81,81,67,105,
81,81,81,81,81,68,107,106,
81,81,81,81,81,69,108,106,
1,70,109,1,
110,1,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,110,
  110,71,110,110,1,
111,1,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,
  111,72,111,111,1,
112,1,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,
  112,73,112,112,1,
1,1,74,4,4,1,
5,75,
79,78,77,113,76,76,
114,77,
115,78,
116,79,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,80,10,117,25,24,21,23,22,21,20,19,
  18,17,16,14,15,13,13,13,9,
82,1,82,82,82,82,82,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,81,57,57,1,
1,82,47,1,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,83,10,39,118,118,118,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,84,10,39,119,119,119,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,85,10,39,120,120,120,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,86,10,39,121,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,87,10,39,122,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,88,10,39,123,13,13,13,9,
47,48,49,45,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,90,10,124,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,91,10,125,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,92,10,126,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,93,10,127,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,94,10,128,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,95,10,129,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,96,10,130,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,97,10,131,18,17,16,14,15,13,13,13,
  9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,98,10,132,18,17,16,14,15,13,13,13,
  9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,99,10,133,19,18,17,16,14,15,13,13,
  13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,100,10,134,19,18,17,16,14,15,13,
  13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,101,10,24,23,22,21,20,19,18,17,16,
  14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,102,10,23,23,22,21,20,19,18,17,16,
  14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,103,10,22,23,22,21,20,19,18,17,16,
  14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,104,10,135,21,23,22,21,20,19,18,
  17,16,14,15,13,13,13,9,
82,1,82,82,82,82,82,1,105,14,14,1,
82,1,82,82,82,82,82,136,106,136,136,1,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,107,13,13,13,13,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,108,12,12,12,12,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,109,17,17,17,17,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,110,137,137,137,137,32,
  31,30,10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,111,10,10,10,10,32,31,30,
  10,29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
81,81,81,83,81,81,3,71,70,4,5,7,8,6,12,11,26,27,28,112,9,9,9,9,32,31,30,10,
  29,25,24,21,23,22,21,20,19,18,17,16,14,15,13,13,13,9,
86,85,87,113,138,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,114,
  69,69,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,115,
  68,68,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,116,
  67,67,1,
139,117,
40,41,55,
40,41,54,
40,41,53,
43,44,45,51,
43,44,45,50,
43,44,45,49,
50,43,
50,42,
50,41,
50,40,
50,39,
50,38,
50,37,
52,53,54,55,56,57,51,35,
52,53,54,55,56,57,51,34,
58,59,32,
58,59,31,
63,64,65,20,
140,136,
141,137,
86,85,87,138,142,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,139,
  58,58,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,140,15,15,1,
1,1,1,1,1,1,1,1,141,11,11,1,
80,142,
  0
};


static const unsigned short ag_sbt[] = {
     0,  25,  27,  73, 106, 130, 154, 178, 217, 224, 263, 308, 330, 352,
   355, 400, 404, 407, 411, 413, 421, 424, 427, 429, 431, 435, 437, 447,
   451, 455, 457, 459, 461, 463, 467, 500, 546, 592, 638, 683, 728, 749,
   756, 758, 779, 800, 821, 858, 879, 900, 921, 946, 967, 988,1009,1030,
  1051,1072,1093,1114,1135,1156,1177,1195,1216,1237,1258,1279,1286,1294,
  1302,1306,1330,1354,1378,1384,1386,1392,1394,1396,1398,1434,1479,1483,
  1506,1529,1552,1576,1600,1624,1628,1655,1682,1709,1736,1763,1790,1817,
  1845,1873,1902,1931,1964,1997,2030,2064,2076,2088,2134,2180,2226,2272,
  2318,2364,2369,2408,2447,2486,2488,2491,2494,2497,2501,2505,2509,2511,
  2513,2515,2517,2519,2521,2523,2531,2539,2542,2545,2549,2551,2553,2558,
  2597,2621,2633,2635
};


static const unsigned short ag_sbe[] = {
    20,  26,  46, 104, 126, 150, 174, 213, 222, 259, 304, 324, 346, 354,
   396, 403, 405, 410, 412, 420, 423, 426, 428, 430, 434, 436, 443, 448,
   452, 456, 458, 460, 462, 465, 498, 519, 565, 611, 679, 724, 745, 754,
   757, 775, 796, 817, 854, 875, 896, 917, 937, 963, 984,1005,1026,1047,
  1068,1089,1110,1131,1152,1173,1191,1212,1233,1254,1275,1284,1291,1299,
  1303,1326,1350,1374,1380,1385,1391,1393,1395,1397,1414,1475,1480,1499,
  1522,1545,1568,1592,1616,1627,1644,1671,1698,1725,1752,1779,1806,1833,
  1861,1889,1918,1947,1980,2013,2046,2072,2084,2107,2153,2199,2245,2291,
  2337,2367,2404,2443,2482,2487,2490,2493,2496,2500,2504,2508,2510,2512,
  2514,2516,2518,2520,2522,2530,2538,2541,2544,2548,2550,2552,2556,2593,
  2617,2629,2634,2635
};


static const unsigned char ag_fl[] = {
  1,0,1,0,2,4,1,1,1,4,4,6,4,4,4,4,1,4,1,1,4,1,4,4,4,1,2,1,3,1,1,4,4,1,4,
  4,1,4,4,4,4,4,4,4,1,3,3,4,1,4,4,4,1,4,4,4,1,4,6,1,2,2,2,2,2,3,2,5,5,5,
  1,1,3,0,2,1,2,2,2,2,5,1,2,1,2,1,1,1,1,2,1
};

static const unsigned char ag_ptt[] = {
    0,  8,  8, 11, 11,  6,  9,  9, 13, 13, 13, 14, 16, 17, 18, 21, 15, 15,
   25, 26, 26, 27, 27, 27, 27, 29, 29, 33, 33, 35, 37, 37, 37, 38, 38, 38,
   41, 41, 41, 41, 41, 41, 41, 41, 44, 44, 44, 53, 51, 51, 51, 51, 56, 56,
   56, 56, 60, 60, 60, 64, 64, 64, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
   69, 79, 79, 80, 80, 80, 80, 80, 80, 23, 23, 54, 54, 84, 84, 84, 91, 91,
    7
};


static void ag_ra(void)
{
  switch(ag_rpx[(PCB).ag_ap]) {
    case 1: ag_rp_1(V(1,(ptnode * *))); break;
    case 2: V(0,(ptnode * *)) = ag_rp_2(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 3: V(0,(ptnode * *)) = ag_rp_3(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 4: V(0,(ptnode * *)) = ag_rp_4(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 5: V(0,(ptnode * *)) = ag_rp_5(V(2,(ptnode * *)), V(3,(ptnode * *))); break;
    case 6: V(0,(ptnode * *)) = ag_rp_6(V(2,(ptnode * *)), V(3,(ptnode * *))); break;
    case 7: V(0,(ptnode * *)) = ag_rp_7(V(2,(char * *))); break;
    case 8: V(0,(ptnode * *)) = ag_rp_8(V(0,(char * *))); break;
    case 9: V(0,(ptnode * *)) = ag_rp_9(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 10: V(0,(ptnode * *)) = ag_rp_10(V(0,(ptnode * *))); break;
    case 11: V(0,(ptnode * *)) = ag_rp_11(V(0,(ptnode * *))); break;
    case 12: V(0,(ptnode * *)) = ag_rp_12(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 13: V(0,(ptnode * *)) = ag_rp_13(V(0,(ptnode * *))); break;
    case 14: V(0,(ptnode * *)) = ag_rp_14(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 15: V(0,(ptnode * *)) = ag_rp_15(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 16: V(0,(ptnode * *)) = ag_rp_16(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 17: V(0,(ptnode * *)) = ag_rp_17(V(0,(ptnode * *))); break;
    case 18: V(0,(ptnode * *)) = ag_rp_18(V(0,(ptnode * *))); break;
    case 19: V(0,(ptnode * *)) = ag_rp_19(V(0,(ptnode * *))); break;
    case 20: V(0,(ptnode * *)) = ag_rp_20(V(0,(ptnode * *))); break;
    case 21: V(0,(ptnode * *)) = ag_rp_21(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 22: V(0,(ptnode * *)) = ag_rp_22(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 23: V(0,(ptnode * *)) = ag_rp_23(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 24: V(0,(ptnode * *)) = ag_rp_24(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 25: V(0,(ptnode * *)) = ag_rp_25(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 26: V(0,(ptnode * *)) = ag_rp_26(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 27: V(0,(ptnode * *)) = ag_rp_27(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 28: V(0,(ptnode * *)) = ag_rp_28(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 29: V(0,(ptnode * *)) = ag_rp_29(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 30: V(0,(ptnode * *)) = ag_rp_30(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 31: V(0,(ptnode * *)) = ag_rp_31(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 32: V(0,(ptnode * *)) = ag_rp_32(V(0,(ptnode * *)), V(2,(ptnode * *))); break;
    case 33: V(0,(ptnode * *)) = ag_rp_33(V(0,(ptnode * *)), V(1,(char * *))); break;
    case 34: V(0,(ptnode * *)) = ag_rp_34(V(0,(char * *))); break;
    case 35: V(0,(ptnode * *)) = ag_rp_35(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 36: V(0,(ptnode * *)) = ag_rp_36(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 37: V(0,(ptnode * *)) = ag_rp_37(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 38: V(0,(ptnode * *)) = ag_rp_38(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 39: V(0,(ptnode * *)) = ag_rp_39(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 40: V(0,(ptnode * *)) = ag_rp_40(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 41: V(0,(ptnode * *)) = ag_rp_41(V(0,(ptnode * *)), V(2,(char * *))); break;
    case 42: V(0,(ptnode * *)) = ag_rp_42(V(0,(ptnode * *)), V(3,(ptnode * *))); break;
    case 43: V(0,(ptnode * *)) = ag_rp_43(V(1,(ptnode * *))); break;
    case 44: V(0,(ptnode * *)) = ag_rp_44(V(1,(ptnode * *))); break;
    case 45: V(0,(ptnode * *)) = ag_rp_45(V(0,(char * *))); break;
    case 46: V(0,(ptnode * *)) = ag_rp_46(V(0,(char * *))); break;
    case 47: V(0,(ptnode * *)) = ag_rp_47(V(0,(char * *))); break;
    case 48: V(0,(ptnode * *)) = ag_rp_48(V(1,(char * *))); break;
    case 49: V(0,(ptnode * *)) = ag_rp_49(); break;
    case 50: V(0,(ptnode * *)) = ag_rp_50(V(2,(ptnode * *))); break;
    case 51: V(0,(ptnode * *)) = ag_rp_51(V(2,(ptnode * *))); break;
    case 52: V(0,(ptnode * *)) = ag_rp_52(V(2,(ptnode * *))); break;
    case 53: V(0,(ptnode * *)) = ag_rp_53(); break;
    case 54: V(0,(ptnode * *)) = ag_rp_54(); break;
    case 55: V(0,(char * *)) = ag_rp_55(V(1,(char * *))); break;
    case 56: V(0,(char * *)) = ag_rp_56(); break;
    case 57: V(0,(char * *)) = ag_rp_57(V(0,(char * *)), V(1,(int *))); break;
    case 58: V(0,(int *)) = ag_rp_58(V(0,(int *))); break;
    case 59: V(0,(int *)) = ag_rp_59(); break;
    case 60: V(0,(int *)) = ag_rp_60(); break;
    case 61: V(0,(int *)) = ag_rp_61(); break;
    case 62: V(0,(int *)) = ag_rp_62(); break;
    case 63: V(0,(int *)) = ag_rp_63(V(2,(int *)), V(3,(int *))); break;
    case 64: V(0,(char * *)) = ag_rp_64(V(0,(int *))); break;
    case 65: V(0,(char * *)) = ag_rp_65(V(0,(char * *)), V(1,(int *))); break;
    case 66: V(0,(char * *)) = ag_rp_66(V(0,(int *))); break;
    case 67: V(0,(char * *)) = ag_rp_67(V(0,(char * *)), V(1,(int *))); break;
    case 68: V(0,(int *)) = ag_rp_68(V(0,(int *))); break;
    case 69: V(0,(int *)) = ag_rp_69(V(0,(int *))); break;
    case 70: V(0,(int *)) = ag_rp_70(V(0,(int *))); break;
  }
}

#define TOKEN_NAMES parse_token_names
const char *const parse_token_names[94] = {
  "query",
  "\"contains\"",
  "\"for\"",
  "\"let\"",
  "\"where\"",
  "\"in\"",
  "query",
  "ws",
  "",
  "expr",
  "';'",
  "",
  "eof",
  "bind expr",
  "lambda expr",
  "filter expr",
  "for head",
  "let head",
  "lambda head",
  "'{'",
  "'}'",
  "binding name",
  "'\\\\'",
  "ident",
  "\"=\"",
  "tuple expr",
  "real tuple expr",
  "path expr",
  "','",
  "qualified path element",
  "\"->\"",
  "\"->*\"",
  "\"->+\"",
  "path element",
  "'\\?'",
  "value expr",
  "'!'",
  "logical expr",
  "equality expr",
  "\"&&\"",
  "\"||\"",
  "comparison expr",
  "\"==\"",
  "\"!=\"",
  "cons",
  "'~'",
  "\"!~\"",
  "'<'",
  "'>'",
  "\"<=\"",
  "\">=\"",
  "term",
  "':'",
  "range start",
  "number",
  "\"to\"",
  "factor",
  "'+'",
  "'-'",
  "\"++\"",
  "suffix expr",
  "'*'",
  "'/'",
  "'%'",
  "prefix expr",
  "'.'",
  "'('",
  "')'",
  "base expr",
  "string",
  "'@'",
  "\"**\"",
  "'['",
  "']'",
  "\"[[\"",
  "\"]]\"",
  "\"()\"",
  "\"[]\"",
  "'\\\"'",
  "string body",
  "string char",
  "",
  "'n'",
  "'t'",
  "hex digit",
  "letter",
  "",
  "digit",
  "",
  "",
  "ws char",
  "",
  "",
  "",

};


static const unsigned char ag_ctn[] = {
    0,0,  7,1,  0,0, 69,1, 68,1, 68,1, 68,1, 68,1, 68,1, 68,1, 68,1, 64,1,
   64,1, 60,1, 44,1, 56,1, 44,1, 51,1, 44,1, 41,1, 38,1, 37,1, 33,1, 29,1,
   27,1, 26,1, 18,1, 17,1, 16,1, 15,1, 14,1, 13,1, 13,1,  0,0, 79,1, 68,2,
   68,2, 68,2, 23,1, 68,1, 60,2, 60,2, 53,2, 56,2, 56,2, 56,2, 54,1, 51,2,
   51,2, 51,2, 44,2, 41,2, 41,2, 41,2, 41,2, 41,2, 41,2, 41,2, 38,2, 38,2,
   37,2, 37,2, 33,2, 27,2, 27,2, 27,2, 26,2, 18,2, 17,2, 16,2, 15,2, 14,2,
   13,2, 13,2,  0,0,  0,0, 80,1, 68,3, 68,3, 68,3, 60,3, 23,1, 53,3, 56,3,
   56,3, 56,3, 51,3, 51,3, 51,3, 51,1, 41,3, 41,3, 41,3, 41,3, 41,3, 41,3,
   41,3, 38,3, 38,3, 37,3, 37,3, 27,3, 27,3, 27,3, 26,3, 23,1, 21,1, 17,3,
   16,3, 15,3, 14,3, 13,3, 13,3, 80,2, 68,4, 68,4, 68,4, 60,4, 60,1, 60,1,
   60,1, 56,1, 56,1, 56,1, 44,1, 44,1, 44,1, 44,1, 44,1, 44,1, 44,1, 41,1,
   41,1, 38,1, 38,1, 27,1, 21,2, 14,4, 80,3, 60,5, 21,3, 14,5, 80,4
};

#ifndef MISSING_FORMAT
#define MISSING_FORMAT "Missing %s"
#endif
#ifndef UNEXPECTED_FORMAT
#define UNEXPECTED_FORMAT "Unexpected %s"
#endif
#ifndef UNNAMED_TOKEN
#define UNNAMED_TOKEN "input"
#endif


static void ag_diagnose(void) {
  int ag_snd = (PCB).sn;
  int ag_k = ag_sbt[ag_snd];

  if (*TOKEN_NAMES[ag_tstt[ag_k]] && ag_astt[ag_k + 1] == ag_action_8) {
    sprintf((PCB).ag_msg, MISSING_FORMAT, TOKEN_NAMES[ag_tstt[ag_k]]);
  }
  else if (ag_astt[ag_sbe[(PCB).sn]] == ag_action_8
          && (ag_k = (int) ag_sbe[(PCB).sn] + 1) == (int) ag_sbt[(PCB).sn+1] - 1
          && *TOKEN_NAMES[ag_tstt[ag_k]]) {
    sprintf((PCB).ag_msg, MISSING_FORMAT, TOKEN_NAMES[ag_tstt[ag_k]]);
  }
  else if ((PCB).token_number && *TOKEN_NAMES[(PCB).token_number]) {
    sprintf((PCB).ag_msg, UNEXPECTED_FORMAT, TOKEN_NAMES[(PCB).token_number]);
  }
  else if (isprint((*(PCB).lab)) && (*(PCB).lab) != '\\') {
    char buf[20];
    sprintf(buf, "\'%c\'", (char) (*(PCB).lab));
    sprintf((PCB).ag_msg, UNEXPECTED_FORMAT, buf);
  }
  else sprintf((PCB).ag_msg, UNEXPECTED_FORMAT, UNNAMED_TOKEN);
  (PCB).error_message = (PCB).ag_msg;


}
static int ag_action_1_r_proc(void);
static int ag_action_2_r_proc(void);
static int ag_action_3_r_proc(void);
static int ag_action_4_r_proc(void);
static int ag_action_1_s_proc(void);
static int ag_action_3_s_proc(void);
static int ag_action_1_proc(void);
static int ag_action_2_proc(void);
static int ag_action_3_proc(void);
static int ag_action_4_proc(void);
static int ag_action_5_proc(void);
static int ag_action_6_proc(void);
static int ag_action_7_proc(void);
static int ag_action_8_proc(void);
static int ag_action_9_proc(void);
static int ag_action_10_proc(void);
static int ag_action_11_proc(void);
static int ag_action_12_proc(void);


static int (*const  ag_r_procs_scan[])(void) = {
  ag_action_1_r_proc,
  ag_action_2_r_proc,
  ag_action_3_r_proc,
  ag_action_4_r_proc
};

static int (*const  ag_s_procs_scan[])(void) = {
  ag_action_1_s_proc,
  ag_action_2_r_proc,
  ag_action_3_s_proc,
  ag_action_4_r_proc
};

static int (*const  ag_gt_procs_scan[])(void) = {
  ag_action_1_proc,
  ag_action_2_proc,
  ag_action_3_proc,
  ag_action_4_proc,
  ag_action_5_proc,
  ag_action_6_proc,
  ag_action_7_proc,
  ag_action_8_proc,
  ag_action_9_proc,
  ag_action_10_proc,
  ag_action_11_proc,
  ag_action_12_proc
};


static int ag_rns(int ag_t, int *ag_sx, int ag_snd) {
  while (1) {
    int ag_act, ag_k = ag_sbt[ag_snd], ag_lim = ag_sbt[ag_snd+1];
    int ag_p;

    while (ag_k < ag_lim && ag_tstt[ag_k] != ag_t) ag_k++;
    if (ag_k == ag_lim) break;
    ag_act = ag_astt[ag_k];
    ag_p = ag_pstt[ag_k];
    if (ag_act == ag_action_2) return ag_p;
    if (ag_act == ag_action_10 || ag_act == ag_action_11) {
      (*ag_sx)--;
      return ag_snd;
    }
    if (ag_act != ag_action_3 &&
      ag_act != ag_action_4) break;
    *ag_sx -= (ag_fl[ag_p] - 1);
    ag_snd = (PCB).ss[*ag_sx];
    ag_t = ag_ptt[ag_p];
  }
  return 0;
}

static int ag_jns(int ag_t) {
  int ag_k;

  ag_k = ag_sbt[(PCB).sn];
  while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
  while (1) {
    int ag_p = ag_pstt[ag_k];
    int ag_sd;

    switch (ag_astt[ag_k]) {
    case ag_action_2:
      (PCB).ss[(PCB).ssx] = (PCB).sn;
      return ag_p;
    case ag_action_10:
    case ag_action_11:
      return (PCB).ss[(PCB).ssx--];
    case ag_action_9:
      (PCB).ss[(PCB).ssx] = (PCB).sn;
      (PCB).ssx++;
      (PCB).sn = ag_p;
      ag_k = ag_sbt[(PCB).sn];
      while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
      continue;
    case ag_action_3:
    case ag_action_4:
      ag_sd = ag_fl[ag_p] - 1;
      if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
      else (PCB).ss[(PCB).ssx] = (PCB).sn;
      ag_t = ag_ptt[ag_p];
      ag_k = ag_sbt[(PCB).sn+1];
      while (ag_tstt[--ag_k] != ag_t);
      continue;
    case ag_action_5:
    case ag_action_6:
      if (ag_fl[ag_p]) break;
      (PCB).sn = ag_rns(ag_ptt[ag_p],&(PCB).ssx, (PCB).sn);
      (PCB).ss[++(PCB).ssx] = (PCB).sn;
      ag_k = ag_sbt[(PCB).sn];
      while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
      continue;
    }
    break;
  }
  return 0;
}


static int ag_atx(int ag_t, int *ag_sx, int ag_snd) {
  int ag_k, ag_f;
  int ag_save_btsx = (PCB).btsx;
  int ag_flag = 1;

  while (1) {
    int ag_a;

    (PCB).bts[128 - ++(PCB).btsx] = *ag_sx;
    (PCB).ss[128 - (PCB).btsx] = (PCB).ss[*ag_sx];
    (PCB).ss[*ag_sx] = ag_snd;
    ag_k = ag_sbt[ag_snd];
    while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
    ag_a = ag_astt[ag_k];
    if (ag_a == ag_action_2 ||
        ag_a == ag_action_3 ||
        ag_a == ag_action_10 ||
        ag_a == ag_action_11 ||
        ag_a == ag_action_1 ||
        ag_a == ag_action_4) break;
    if ((ag_a == ag_action_5 ||
        ag_a == ag_action_6) &&
        (ag_k = ag_fl[ag_f = ag_pstt[ag_k]]) == 0) {
        ag_snd = ag_rns(ag_ptt[ag_f],ag_sx, (PCB).ss[*ag_sx]);
        (*ag_sx)++;
        continue;
    }
    if (ag_a == ag_action_9) {
      ag_snd = ag_pstt[ag_k];
      (*ag_sx)++;
      continue;
    }
    ag_flag = 0;
    break;
  }
  while ((PCB).btsx > ag_save_btsx) {
    *ag_sx = (PCB).bts[128 - (PCB).btsx];
    (PCB).ss[*ag_sx] = (PCB).ss[128 - (PCB).btsx--];
  }
  return ag_flag;
}

static int ag_tst_tkn(void) {
  int ag_rk, ag_sx, ag_snd;

  for (ag_rk = 0; ag_rk < (PCB).ag_lrss; ag_rk += 2) {
    ag_sx = (PCB).ag_rss[ag_rk];
    if (ag_sx > (PCB).ssx) continue;
    ag_snd = (PCB).ag_rss[ag_rk + 1];
    if (ag_sx > (PCB).ag_min_depth) continue;
    if (ag_atx((PCB).token_number, &ag_sx, ag_snd)) break;
  }
  return ag_rk;
}

static void ag_set_error_procs(void);

static void ag_auto_resynch(void) {
  int ag_sx;
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  if ((PCB).ag_error_depth && (PCB).ag_min_depth >= (PCB).ag_error_depth) {
    (PCB).ssx = (PCB).ag_error_depth;
    (PCB).sn = (PCB).ss[(PCB).ssx];
  }
  else {
    ag_diagnose();
    SYNTAX_ERROR;
    if ((PCB).exit_flag != AG_RUNNING_CODE) return;
    (PCB).ag_error_depth = (PCB).ag_min_depth = 0;
    (PCB).ag_lrss = 0;
    (PCB).ss[ag_sx = (PCB).ssx] = (PCB).sn;
    (PCB).ag_min_depth = (PCB).ag_rss[(PCB).ag_lrss++] = ag_sx;
    (PCB).ag_rss[(PCB).ag_lrss++] = (PCB).sn;
    while (ag_sx && (PCB).ag_lrss < 2*128) {
      int ag_t = 0, ag_x, ag_s, ag_sxs = ag_sx;

      while (ag_sx && (ag_t = ag_ctn[2*(PCB).sn]) == 0) (PCB).sn = (PCB).ss[--ag_sx];
      if (ag_t) (PCB).sn = (PCB).ss[ag_sx -= ag_ctn[2*(PCB).sn +1]];
      else {
        if (ag_sx == 0) (PCB).sn = 0;
        ag_t = ag_ptt[0];
      }
      if ((ag_s = ag_rns(ag_t, &ag_sx, (PCB).sn)) == 0) break;
      for (ag_x = 0; ag_x < (PCB).ag_lrss; ag_x += 2)
        if ((PCB).ag_rss[ag_x] == ag_sx + 1 && (PCB).ag_rss[ag_x+1] == ag_s) break;
      if (ag_x == (PCB).ag_lrss) {
        (PCB).ag_rss[(PCB).ag_lrss++] = ++ag_sx;
        (PCB).ag_rss[(PCB).ag_lrss++] = (PCB).sn = ag_s;
      }
      else if (ag_sx >= ag_sxs) ag_sx--;
    }
    ag_set_error_procs();
  }
  (PCB).ssx++;
  (PCB).sn = 143;
  (PCB).ag_rk1 = (PCB).ag_lrss;
  return;
}

static int ag_action_12_proc(void) {
  int ag_k, ag_rk;

  (PCB).ssx--;
  if ((PCB).ag_rk1 == (PCB).ag_lrss) {
    (PCB).ag_rk1 = ag_tst_tkn();
    (PCB).ssx++;
    if ((PCB).token_number == 12)
      {(PCB).exit_flag = AG_SYNTAX_ERROR_CODE; return 0;}
    (PCB).ag_tk1 = (PCB).token_number;
    ag_track();
    return 0;
  }
  ag_rk = ag_tst_tkn();
  if (ag_rk < (PCB).ag_rk1) {
    ag_k = 0;
    ag_track();
  }
  else {
    ag_k = 1;
    ag_rk = (PCB).ag_rk1;
    (PCB).token_number = (parse_token_type) (PCB).ag_tk1;
    (PCB).rx = 0;
  }
  (PCB).ag_min_depth = (PCB).ssx = (PCB).ag_rss[ag_rk++];
  (PCB).sn = (PCB).ss[(PCB).ssx] = (PCB).ag_rss[ag_rk];
  (PCB).sn = ag_jns((PCB).token_number);
  if ((PCB).ag_error_depth == 0 || (PCB).ag_error_depth > (PCB).ssx)
    (PCB).ag_error_depth = (PCB).ssx;
  if (++(PCB).ssx >= 128) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
    return 0;
  }
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ag_tmp_depth = (PCB).ag_min_depth;
  return ag_k;
}


static int ag_action_10_proc(void) {
  (PCB).btsx = 0, (PCB).drt = -1;
  ag_track();
  return 0;
}

static int ag_action_11_proc(void) {
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(int *) &(PCB).vs[(PCB).ssx]) = *(PCB).lab;
  (PCB).ssx--;
  ag_ra();
  (PCB).ssx++;
  ag_track();
  return 0;
}

static int ag_action_3_r_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).btsx = 0, (PCB).drt = -1;
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra();
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_3_s_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).btsx = 0, (PCB).drt = -1;
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra();
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_4_r_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  return 1;
}

static int ag_action_2_proc(void) {
  (PCB).btsx = 0, (PCB).drt = -1;
  if ((PCB).ssx >= 128) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
  }
  (*(int *) &(PCB).vs[(PCB).ssx]) = *(PCB).lab;
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  ag_track();
  return 0;
}

static int ag_action_9_proc(void) {
  if ((PCB).drt == -1) {
    (PCB).drt=(PCB).token_number;
    (PCB).dssx=(PCB).ssx;
    (PCB).dsn=(PCB).sn;
  }
  ag_prot();
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  (PCB).rx = 0;
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_2_r_proc(void) {
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  return 0;
}

static int ag_action_7_proc(void) {
  --(PCB).ssx;
  (PCB).exit_flag = AG_SUCCESS_CODE;
  (PCB).rx = 0;
  return 0;
}

static int ag_action_1_proc(void) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  ag_track();
  return 0;
}

static int ag_action_1_r_proc(void) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  return 0;
}

static int ag_action_1_s_proc(void) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  return 0;
}

static int ag_action_4_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(int *) &(PCB).vs[(PCB).ssx]) = *(PCB).lab;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else (PCB).ss[(PCB).ssx] = (PCB).sn;
  ag_track();
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).s_procs[ag_astt[ag_t1]])() == 0) break;
  }
  return 0;
}

static int ag_action_3_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(int *) &(PCB).vs[(PCB).ssx]) = *(PCB).lab;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else (PCB).ss[(PCB).ssx] = (PCB).sn;
  ag_track();
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra();
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).s_procs[ag_astt[ag_t1]])() == 0) break;
  }
  return 0;
}

static int ag_action_8_proc(void) {
  ag_undo();
  (PCB).rx = 0;
  ag_auto_resynch();
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_5_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap];
  (PCB).btsx = 0, (PCB).drt = -1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else {
    (PCB).ss[(PCB).ssx] = (PCB).sn;
  }
  (PCB).rx = 0;
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra();
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).r_procs[ag_astt[ag_t1]])() == 0) break;
  }
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_6_proc(void) {
  int ag_sd = ag_fl[(PCB).ag_ap];
  (PCB).reduction_token = (parse_token_type) ag_ptt[(PCB).ag_ap];
  if ((PCB).drt == -1) {
    (PCB).drt=(PCB).token_number;
    (PCB).dssx=(PCB).ssx;
    (PCB).dsn=(PCB).sn;
  }
  if (ag_sd) {
    (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  }
  else {
    ag_prot();
    (PCB).vs[(PCB).ssx] = ag_null_value;
    (PCB).ss[(PCB).ssx] = (PCB).sn;
  }
  (PCB).rx = 0;
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).r_procs[ag_astt[ag_t1]])() == 0) break;
  }
  return (PCB).exit_flag == AG_RUNNING_CODE;
}


static void ag_check_depth(int ag_fl) {
  int ag_sx = (PCB).ssx - ag_fl;
  if ((PCB).ag_error_depth && ag_sx < (PCB).ag_tmp_depth) (PCB).ag_tmp_depth = ag_sx;
}

static int ag_action_3_er_proc(void) {
  ag_check_depth(ag_fl[(PCB).ag_ap] - 1);
  return ag_action_4_r_proc();
}

static int ag_action_2_e_proc(void) {
  ag_action_2_proc();
  (PCB).ag_min_depth = (PCB).ag_tmp_depth;
  return 0;
}

static int ag_action_4_e_proc(void) {
  ag_check_depth(ag_fl[(PCB).ag_ap] - 1);
  (PCB).ag_min_depth = (PCB).ag_tmp_depth;
  return ag_action_4_proc();
}

static int ag_action_6_e_proc(void) {
  ag_check_depth(ag_fl[(PCB).ag_ap]);
  return ag_action_6_proc();
}

static int ag_action_11_e_proc(void) {
  return ag_action_10_proc();
}

static int (*ag_r_procs_error[])(void) = {
  ag_action_1_r_proc,
  ag_action_2_r_proc,
  ag_action_3_er_proc,
  ag_action_3_er_proc
};

static int (*ag_s_procs_error[])(void) = {
  ag_action_1_s_proc,
  ag_action_2_r_proc,
  ag_action_3_er_proc,
  ag_action_3_er_proc
};

static int (*ag_gt_procs_error[])(void) = {
  ag_action_1_proc,
  ag_action_2_e_proc,
  ag_action_4_e_proc,
  ag_action_4_e_proc,
  ag_action_6_e_proc,
  ag_action_6_e_proc,
  ag_action_7_proc,
  ag_action_8_proc,
  ag_action_9_proc,
  ag_action_10_proc,
  ag_action_11_e_proc,
  ag_action_12_proc
};

static void ag_set_error_procs(void) {
  (PCB).gt_procs = ag_gt_procs_error;
  (PCB).r_procs = ag_r_procs_error;
  (PCB).s_procs = ag_s_procs_error;
}


void init_parse(void) {
  unsigned ag_t1;
  ag_t1 = 0;
  (PCB).rx = (PCB).fx = 0;
  (PCB).gt_procs = ag_gt_procs_scan;
  (PCB).r_procs = ag_r_procs_scan;
  (PCB).s_procs = ag_s_procs_scan;
  (PCB).ag_error_depth = (PCB).ag_min_depth = (PCB).ag_tmp_depth = 0;
  (PCB).ag_resynch_active = 0;
  (PCB).ss[0] = (PCB).sn = (PCB).ssx = 0;
  (PCB).exit_flag = AG_RUNNING_CODE;
  (PCB).key_sp = NULL;
  (PCB).key_state = 0;
  (PCB).line = FIRST_LINE;
  (PCB).column = FIRST_COLUMN;
  (PCB).btsx = 0, (PCB).drt = -1;
  while (ag_tstt[ag_t1] == 0) {
    (PCB).ag_ap = ag_pstt[ag_t1];
    (*(PCB).gt_procs[ag_astt[ag_t1]])();
    ag_t1 = ag_sbt[(PCB).sn];
  }
}

void parse(void) {
  (PCB).lab[(PCB).fx++] = (PCB).input_code;
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    while (1) {
      const  unsigned char *ag_p;
      int ag_ch;
      if ((PCB).rx >= (PCB).fx) return;
      ag_ch = CONVERT_CASE((PCB).lab[(PCB).rx++]);
      if ((PCB).key_sp) {
        if (ag_ch != *(PCB).key_sp++) {
          (PCB).rx = (PCB).save_index;
          (PCB).key_sp = NULL;
          (PCB).key_state = 0;
          break;
        } else if (*(PCB).key_sp) continue;
        if (ag_key_act[(PCB).key_state] == ag_cf_end_key) {
          int ag_k1;
          int ag_k2;
          if ((PCB).rx >= (PCB).fx) {
            (PCB).rx--;
            (PCB).key_sp--;
            return;
          }
          (PCB).key_sp = NULL;
          ag_k1 = ag_key_parm[(PCB).key_state];
          ag_k2 = ag_key_pt[ag_k1];
          if (ag_key_itt[ag_k2 + CONVERT_CASE((PCB).lab[(PCB).rx])])
            (PCB).rx = (PCB).save_index;
          else {
            (PCB).token_number =  (parse_token_type) ag_key_pt[ag_k1+1];
            (PCB).key_state = 0;
          }
          break;
        }
        else {
          (PCB).token_number = (parse_token_type) ag_key_parm[(PCB).key_state];
          (PCB).key_state = 0;
          (PCB).key_sp = NULL;
        }
        break;
      }
      if ((PCB).key_state == 0) {
        (PCB).token_number = (parse_token_type) AG_TCV(ag_ch);
        if (((PCB).key_state = ag_key_index[(PCB).sn]) == 0) break;
        (PCB).save_index = 1;
      }
      ag_p = &ag_key_ch[(PCB).key_state];
      if (ag_ch <= 255) while (*ag_p < ag_ch) ag_p++;
      if (*ag_p == ag_ch) {
        (PCB).key_state = (int)(ag_p - ag_key_ch);
        switch (ag_key_act[(PCB).key_state]) {
        case ag_cf_set_key: {
          int ag_k1;
          int ag_k2;
          if ((PCB).rx >= (PCB).fx) {
            (PCB).rx--;
            return;
          }
          ag_k1 = ag_key_parm[(PCB).key_state];
          ag_k2 = ag_key_pt[ag_k1];
          (PCB).key_state = ag_key_jmp[(PCB).key_state];
          if (ag_key_itt[ag_k2 + CONVERT_CASE((PCB).lab[(PCB).rx])]) continue;
          (PCB).save_index = (PCB).rx;
          (PCB).token_number = (parse_token_type) ag_key_pt[ag_k1+1];
          continue;
        }
        case ag_set_key:
          (PCB).save_index = (PCB).rx;
          (PCB).token_number = (parse_token_type) ag_key_parm[(PCB).key_state];
        case ag_jmp_key:
          (PCB).key_state = ag_key_jmp[(PCB).key_state];
          continue;
        case ag_cf_end_key:
        case ag_end_key:
          (PCB).key_sp = ag_key_ends + ag_key_jmp[(PCB).key_state];
          continue;
        case ag_accept_key:
          (PCB).token_number = (parse_token_type) ag_key_parm[(PCB).key_state];
          (PCB).key_state = 0;
          break;
        case ag_cf_accept_key: {
          int ag_k1;
          int ag_k2;
          if ((PCB).rx >= (PCB).fx) {
            (PCB).rx--;
            return;
          }
          ag_k1 = ag_key_parm[(PCB).key_state];
          ag_k2 = ag_key_pt[ag_k1];
          if (ag_key_itt[ag_k2 + CONVERT_CASE((PCB).lab[(PCB).rx])])
            (PCB).rx = (PCB).save_index;
          else {
            (PCB).token_number = (parse_token_type) ag_key_pt[ag_k1+1];
            (PCB).key_state = 0;
          }
          break;
        }
        }
        break;
      } else {
        (PCB).rx = (PCB).save_index;
        (PCB).key_state = 0;
        break;
      }
    }

    {
      unsigned ag_t1 = ag_sbt[(PCB).sn];
      unsigned ag_t2 = ag_sbe[(PCB).sn] - 1;
      do {
        unsigned ag_tx = (ag_t1 + ag_t2)/2;
        if (ag_tstt[ag_tx] > (unsigned char)(PCB).token_number)
          ag_t1 = ag_tx + 1;
        else ag_t2 = ag_tx;
      } while (ag_t1 < ag_t2);
      if (ag_tstt[ag_t1] != (PCB).token_number)  ag_t1 = ag_sbe[(PCB).sn];
      (PCB).ag_ap = ag_pstt[ag_t1];
      (*(PCB).gt_procs[ag_astt[ag_t1]])();
    }
  }
}


