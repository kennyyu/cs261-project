/*
 * Copyright 2008, 2009
 *	The President and Fellows of Harvard College.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <string.h>
#include <stdlib.h>  // for strtod
#include <limits.h>  // for INT_MAX
#include <errno.h>   // for strtod

#include "pqlvalue.h"
#include "pttree.h"
#include "ptprivate.h"
#include "pqlcontext.h"
#include "pql.h"


/* type of input tokens */
struct tokstr {
   const char *str;
   size_t len;
};


/*
 * AnaGram, A System for Syntax Directed Programming
 * File generated by: Snap 2.40-20070527   Dec 16 2009
 *
 * AnaGram Parsing Engine
 * Copyright 1993-2002 Parsifal Software. All Rights Reserved.
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

#ifndef PTPARSE_H_1270595738
#include "ptpcb.h"
#endif

#ifndef PTPARSE_H_1270595738
#error Mismatched header file
#endif

#include <ctype.h>
#include <stdio.h>

#define RULE_CONTEXT (&((PCB).cs[(PCB).ssx]))
#define ERROR_CONTEXT ((PCB).cs[(PCB).error_frame_ssx])
#define CONTEXT ((PCB).cs[(PCB).ssx])


#ifndef PCB_TYPE
#define PCB_TYPE ptparse_pcb_type
#endif


#define PCB (*pcb_pointer)
#define PCB_DECL PCB_TYPE *pcb_pointer
#define PCB_POINTER pcb_pointer
#define INPUT_VALUE(type) *(type *) &(PCB).input_value

#line 413 "/home/vfiler/dholland/projects/pql/hg/rehacking/libpql/ptparse.syn"
#define SYNTAX_ERROR          noparse(PCB.pql, (PCB).error_message)
#define PARSER_STACK_OVERFLOW noparse(PCB.pql, "Parser stack overflow")
#define REDUCTION_TOKEN_ERROR noparse(PCB.pql, "Reduction token error")

static void noparse(struct pqlcontext *pql, const char *msg) {
   complain(pql, pql->pcb->line, pql->pcb->column, "%s", msg);
   pql->pcb->failed = true;
}

void parser_begin(struct pqlcontext *pql) {
   PQLASSERT(pql->pcb == NULL);

   pql->pcb = domalloc(pql, sizeof(*pql->pcb));
   init_ptparse(pql->pcb);
   pql->pcb->pql = pql;
   pql->pcb->result = NULL;
   pql->pcb->failed = false;
}

void parser_send(struct pqlcontext *pql,
		 unsigned line, unsigned col,
		 int code, const char *value, size_t valuelen) {
   pql->pcb->input_code = code;
   pql->pcb->input_value.str = value;
   pql->pcb->input_value.len = valuelen;
   pql->pcb->line = line;
   pql->pcb->column = col;
   ptparse(pql->pcb);
}

void parser_fail(struct pqlcontext *pql) {
   pql->pcb->failed = true;
}

/*
 * This does not issue the eof token; that's passed to parser_send().
 */
struct ptexpr *parser_end(struct pqlcontext *pql) {
   struct ptexpr *ret;

   PQLASSERT(pql->pcb != NULL);

   if (pql->pcb->exit_flag != AG_SUCCESS_CODE) {
      pql->pcb->failed = true;
   }
   if (pql->pcb->failed) {
      ptmanager_destroyall(pql->ptm);
      ret = NULL;
   }
   else {
      ret = pql->pcb->result;
   }
   dofree(pql, pql->pcb, sizeof(*pql->pcb));
   pql->pcb = NULL;
   return ret;
}

////////////////////////////////////////////////////////////

static int getdigit(int ch, int base, unsigned *ret) {
   if (ch >= '0' && ch <= '9') {
      ch = ch - '0';
   }
   else if (ch >= 'A' && ch <= 'Z') {
      ch = ch + 10 - 'A';
   }
   else if (ch >= 'a' && ch <= 'z') {
      ch = ch + 10 - 'a';
   }
   else {
      return -1;
   }
   if (ch >= base) {
      return -1;         
   }
   *ret = ch;
   return 0;
}

static struct pqlvalue *getint(struct pqlcontext *pql,
			       const char *str, size_t len) {
   unsigned base, val, nextval, digit;
   size_t pos;

   pos = 0;

   if (len > 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {
      pos += 2;
      base = 16;
   }
   else if (str[0] == '0') {
      base = 8;
   }
   else {
      base = 10;
   }

   val = 0;
   while (pos < len) {
      if (getdigit(str[pos++], base, &digit)) {
         complain(pql, pql->pcb->line, pql->pcb->column,
		  "Invalid number");
         pql->pcb->failed = true;
         break;
      }
      nextval = val * base + digit;
      if (nextval < val || nextval > INT_MAX) {
         complain(pql, pql->pcb->line, pql->pcb->column,
		  "Number too large");
         pql->pcb->failed = true;
         break;
      }
      val = nextval;
   }

   return pqlvalue_int(pql, (int)val);
}

static struct pqlvalue *getdouble(struct pqlcontext *pql,
			          const char *str, size_t len) {
   char *tmp, *ep;
   double val;

   /*
    * Sigh. But what choice is there?
    */

   tmp = domalloc(pql, len+1);
   memcpy(tmp, str, len);
   tmp[len] = 0;

   errno = 0;
   val = strtod(tmp, &ep);
   if (errno != 0 || *ep != 0) {
      complain(pql, pql->pcb->line, pql->pcb->column,
	       "Invalid floating point constant");
      pql->pcb->failed = true;
   }
   dofree(pql, tmp, len+1);

   return pqlvalue_float(pql, val);
}

static struct pqlvalue *getstring(struct pqlcontext *pql,
			          const char *str, size_t len) {
   struct pqlvalue *ret;
   char *result;
   size_t pos, rpos;
   unsigned ct, val, nextval, digit;
   bool complained = false;

   PQLASSERT(str[0] == '"');
   if (len < 2 || str[len-1] != '"') {
      /* already reported as an error; we will fail, so cut a corner */
      return pqlvalue_string(pql, "<ERROR>");
   }

   /* skip opening quote */
   str++;
   len--;

   /* skip closing quote */
   len--;

   result = domalloc(pql, len+1);
   pos = rpos = 0;
   while (pos < len) {
      if (str[pos] == '\\') {
         pos++;
         /* note: cannot have run past len */
         switch (str[pos]) {
	    case '\\': pos++; result[rpos++] = '\\'; break;
	    case '"': pos++; result[rpos++] = '"'; break;
	    case 'a': pos++; result[rpos++] = '\a'; break;
	    case 'b': pos++; result[rpos++] = '\b'; break;
	    case 't': pos++; result[rpos++] = '\t'; break;
	    case 'n': pos++; result[rpos++] = '\n'; break;
	    case 'v': pos++; result[rpos++] = '\v'; break;
	    case 'f': pos++; result[rpos++] = '\f'; break;
	    case 'r': pos++; result[rpos++] = '\r'; break;
            case 'x':
	      pos++;
	      ct = 0;
              val = 0;
              while (getdigit(str[pos], 16, &digit) == 0) {
		 /* Because we have a quote at the end this won't run off */
		 pos++;
		 nextval = val*16 + digit;
		 if (nextval < val) {
		    if (!complained) {
		       complain(pql, pql->pcb->line, pql->pcb->column,
				"Integer overflow in escape sequence");
		       pql->pcb->failed = 1;
		       complained = true;
		    }
		    break;
		 }
		 ct++;
		 val = nextval;
	      }
	      if (ct == 0) {
		 goto invalid;
	      }
	      result[rpos++] = val;
	      break;
	    default:
	      if (getdigit(str[pos], 8, &digit) == 0) {
		 pos++;
		 val = digit;
		 /* Because we have a quote at the end this won't run off */
		 if (getdigit(str[pos], 8, &digit) == 0) {
		    pos++;
		    val = val*8 + digit;
		 }
		 if (getdigit(str[pos], 8, &digit) == 0) {
		    pos++;
		    val = val*8 + digit;
		 }
		 result[rpos++] = val;
		 break;
	      }
            invalid:
	      if (!complained) {
		 complain(pql, pql->pcb->line, pql->pcb->column,
			  "Invalid escape sequence");
		 pql->pcb->failed = 1;
		 complained = true;
	      }
	      pos++;
	      break;
         }
      }
      else {
         result[rpos++] = str[pos++];
      }
   }
   result[rpos] = 0;

   if (rpos == len) {
      return pqlvalue_string_consume(pql, result);
   }
   else {
      PQLASSERT(rpos < len);
      /* string in value must have its real length for memory accounting */
      ret = pqlvalue_string(pql, result);
      dofree(pql, result, len+1);
      return ret;
   }
}

////////////////////////////////////////////////////////////

#define EMPTY(type)            pt##type##list_empty(PCB.pql)
#define START(type, elem)      pt##type##list_start(PCB.pql, elem)
#define ADD(type, list, elem)  (pt##type##list_add(PCB.pql, list, elem), list)

#define MKPATH(subtype, ...) mkptpath_##subtype(PCB.pql, __VA_ARGS__)
#define MKEXPR(subtype, ...) mkptexpr_##subtype(PCB.pql, __VA_ARGS__)

static struct ptexprarray *ptexprlist_empty(struct pqlcontext *pql) {
   struct ptexprarray *arr;

   arr = ptexprarray_create(pql);
   ptmanager_add_exprarray(pql->ptm, arr);
   return arr;
}

static struct ptexprarray *ptexprlist_start(struct pqlcontext *pql,
					    struct ptexpr *e) {
   struct ptexprarray *arr;

   arr = ptexprarray_create(pql);
   ptmanager_add_exprarray(pql->ptm, arr);
   ptexprarray_add(pql, arr, e, NULL);
   return arr;
}

static void ptexprlist_add(struct pqlcontext *pql,
			   struct ptexprarray *arr,
			   struct ptexpr *e) {
   (void)pql;
   ptexprarray_add(pql, arr, e, NULL);
}

static struct ptcolumnvararray *ptcolumnvarlist_start(struct pqlcontext *pql,
						      struct ptcolumnvar *v) {
   struct ptcolumnvararray *arr;

   arr = ptcolumnvararray_create(pql);
   ptmanager_add_columnvararray(pql->ptm, arr);
   ptcolumnvararray_add(pql, arr, v, NULL);
   return arr;
}

static void ptcolumnvarlist_add(struct pqlcontext *pql,
				struct ptcolumnvararray *arr,
				struct ptcolumnvar *v) {
   (void)pql;
   ptcolumnvararray_add(pql, arr, v, NULL);
}

////////////////////////////////////////////////////////////

/*
 * These are not normally used (the logic below specifically avoids
 * generating vacuous layers containing sequences of length 1 and
 * alternates of one choice) but enabling them and their call sites
 * above is useful for making sure normalize really works: there may
 * legitimately be some test diffs, particularly extra inserted
 * parentheses in paths, but the output from normalize downstream
 * should always remain identical.
 */
#if 0
static struct ptpath *pathseq_start(struct pqlcontext *pql, struct ptpath *p) {
   struct ptpath *reallist;

   reallist = mkptpath_emptysequence(pql);
   ptpatharray_add(&reallist->sequence.items, p, NULL);
   return reallist;
}

static struct ptpath *pathalt_start(struct pqlcontext *pql, struct ptpath *p) {
   struct ptpath *reallist;

   reallist = mkptpath_emptyalternates(pql);
   ptpatharray_add(&reallist->alternates.items, p, NULL);
   return reallist;
}
#endif

static struct ptpath *pathseq_add(struct pqlcontext *pql,
				  struct ptpath *l, struct ptpath *p) {
   if (l->type == PTP_SEQUENCE && !l->parens) {
      ptpatharray_add(pql, &l->sequence.items, p, NULL);
      return l;
   }
   else {
      struct ptpath *reallist;

      reallist = mkptpath_emptysequence(pql);
      ptpatharray_add(pql, &reallist->sequence.items, l, NULL);
      ptpatharray_add(pql, &reallist->sequence.items, p, NULL);
      return reallist;
   }
}

static struct ptpath *pathalt_add(struct pqlcontext *pql,
				  struct ptpath *l, struct ptpath *p) {
   if (l->type == PTP_ALTERNATES && !l->parens) {
      ptpatharray_add(pql, &l->alternates.items, p, NULL);
      return l;
   }
   else {
      struct ptpath *reallist;

      reallist = mkptpath_emptyalternates(pql);
      ptpatharray_add(pql, &reallist->alternates.items, l, NULL);
      ptpatharray_add(pql, &reallist->alternates.items, p, NULL);
      return reallist;
   }
}

static void path_bindobj(ptparse_pcb_type *pcb,
                         struct ptpath *p, struct ptcolumnvar *v) {
   bool done;
   unsigned num;

   /*
    * Avoid binding object variables into vacuous places.
    *
    * Note that if we do, normalize will clean it up later; however,
    * we'd rather signal an error if the user binds two object variables
    * to the same position, which won't happen unless we hit the same
    * position. (normalize doesn't do this because, at least as things
    * stand, normalize needs to not fail.)
    *
    * Note that the structure of the grammar guarantees that we can
    * only get here and find a sequence or set of alternates that can't
    * be added to any further: either we're working on a finished path
    * inside an expression, via bind_tail_of_path, or the sequences or
    * alternates were in parentheses, p->parens is set, and further
    * sequence or alternate elements encountered will result in a new
    * ptpath wrapping this one. We don't assert that p->parens is set
    * though because it often won't be for the first case.
    */
   done = false;
   while (!done) {
      done = true;

      if (p->type == PTP_SEQUENCE) {
         PQLASSERT(p->bindobjafter == NULL);
         num = ptpatharray_num(&p->sequence.items);
         PQLASSERT(num > 0);
         p = ptpatharray_get(&p->sequence.items, num-1);
         PQLASSERT(p->type != PTP_SEQUENCE);
         done = false;
      }

      if (p->type == PTP_ALTERNATES) {
         num = ptpatharray_num(&p->alternates.items);
         if (num == 1) {
            PQLASSERT(p->bindobjafter == NULL);
            p = ptpatharray_get(&p->sequence.items, num-1);
            PQLASSERT(p->type != PTP_ALTERNATES);
            done = false;
         }
      }
   }

   if (p->bindobjafter != NULL) {
      /*
       * There's already a variable here. This arises from writing
       * "foo.bar.baz{B} as C" or "C in foo.bar.baz{B}", or from
       * things like "foo.bar(.baz{B}){C}". While we could create a
       * let-binding C = B and stuff it in somehow, that would be
       * messy and there's no legitimate reason to write this. So
       * let's just complain instead.
       */
      complain(pcb->pql, pcb->line, pcb->column,
               "Variables %s and %s bind the same object",
               v->name, p->bindobjafter->name);
      pcb->failed = 1;
      return;
   }

   p->bindobjafter = v;
   /* Mark the path position so unification won't touch it. */
   p->dontmerge = true;
}

static void path_bindpath(ptparse_pcb_type *pcb,
                          struct ptpath *p, struct ptcolumnvar *v) {
   unsigned num;
   bool done;

   /*
    * Avoid binding path variables into vacuous places.
    *
    * Again, if we do, normalize will clean it up later, but we'd
    * rather be able to post an error.
    *
    * And again, it's safe to do this here because of the grammar
    * structure.
    */
   done = false;
   while (!done) {
      done = true;

      if (p->type == PTP_SEQUENCE) {
         num = ptpatharray_num(&p->sequence.items);
         if (num == 1) {
            PQLASSERT(p->bindpath == NULL);
            p = ptpatharray_get(&p->sequence.items, num-1);
            PQLASSERT(p->type != PTP_SEQUENCE);
            done = false;
         }
      }

      if (p->type == PTP_ALTERNATES) {
         num = ptpatharray_num(&p->alternates.items);
         if (num == 1) {
            PQLASSERT(p->bindpath == NULL);
            p = ptpatharray_get(&p->sequence.items, num-1);
            PQLASSERT(p->type != PTP_ALTERNATES);
            done = false;
         }
      }
   }

   if (p->bindpath != NULL) {
      /*
       * Likewise; e.g. "foo.bar(.baz@P)@Q".
       */
      complain(pcb->pql, pcb->line, pcb->column,
               "Variables %s and %s bind the same path",
               v->name, p->bindpath->name);
      pcb->failed = 1;
      return;
   }

   p->bindpath = v;
   /* Mark the path position so unification won't touch it. */
   p->dontmerge = true;
}


/*
 * L < all R  ==>  forall V in R: L < V
 * L < any R  ==>  exists V in R: L < V
 */
static struct ptexpr *do_exists_bop(struct pqlcontext *pql,
				    struct ptexpr *l,
				    enum functions op,
				    struct ptexpr *r)
{
   struct ptcolumnvar *v;
   struct ptexpr *pred;

   v = mkptcolumnvar_fresh(pql);
   ptcolumnvar_incref(v);
   pred = mkptexpr_bop(pql, l, op, mkptexpr_readcolumnvar(pql, v));

   return mkptexpr_exists(pql, v, r, pred);
}

static struct ptexpr *do_forall_bop(struct pqlcontext *pql,
				    struct ptexpr *l,
				    enum functions op,
				    struct ptexpr *r)
{
   struct ptcolumnvar *v;
   struct ptexpr *pred;

   v = mkptcolumnvar_fresh(pql);
   ptcolumnvar_incref(v);
   pred = mkptexpr_bop(pql, l, op, mkptexpr_readcolumnvar(pql, v));

   return mkptexpr_forall(pql, v, r, pred);
}

/*
 * [select ... from] x.y.z as K   ==>  x.y.z{K}
 *
 * We need the PCB for path_bindobj, so it can complain if the variable
 * is redundant.
 */
static void bind_tail_of_path(ptparse_pcb_type *pcb,
                              struct ptexpr *pe, struct ptcolumnvar *v) {
   PQLASSERT(pe->type == PTE_PATH);
   path_bindobj(pcb, pe->path.body, v);
}

#line 633 "ptparse.c"

#ifndef CONVERT_CASE
#define CONVERT_CASE(c) (c)
#endif
#ifndef TAB_SPACING
#define TAB_SPACING 8
#endif

#define ag_rp_1(PCB_POINTER, e) (PCB.result = e)

#define ag_rp_2(PCB_POINTER, e) (e)

#define ag_rp_3(PCB_POINTER, e) (e)

#define ag_rp_4(PCB_POINTER, d, s, b) (MKEXPR(select, b, MKEXPR(tuple, s), d))

#define ag_rp_5(PCB_POINTER, f) (MKEXPR(from, f))

#define ag_rp_6(PCB_POINTER, b, e) (MKEXPR(where, b, e))

#define ag_rp_7(PCB_POINTER, b, e) (MKEXPR(where, b, e))

#define ag_rp_8(PCB_POINTER, b, l) (MKEXPR(group, b, l, NULL))

#define ag_rp_9(PCB_POINTER, b, l, v) (MKEXPR(group, b, l, v))

#define ag_rp_10(PCB_POINTER, b, v) (MKEXPR(ungroup, b, v))

#define ag_rp_11(PCB_POINTER, v) (START(columnvar, v))

#define ag_rp_12(PCB_POINTER, l, v) (ADD(columnvar, l, v))

#define ag_rp_13(PCB_POINTER) (false)

#define ag_rp_14(PCB_POINTER) (true)

#define ag_rp_15(PCB_POINTER, e) (START(expr, e))

#define ag_rp_16(PCB_POINTER, l, e) (ADD(expr, l, e))

#define ag_rp_17(PCB_POINTER, e) (e)

#define ag_rp_18(PCB_POINTER, e, x) (MKEXPR(rename_static, x.str, x.len, e))

#define ag_rp_19(PCB_POINTER, e, p) (MKEXPR(rename_computed, p, e))

#define ag_rp_20(PCB_POINTER, x, e) (MKEXPR(rename_static, x.str, x.len, e))

#define ag_rp_21(PCB_POINTER, p, e) (MKEXPR(rename_computed, p, e))

#define ag_rp_22(PCB_POINTER) (EMPTY(expr))

#define ag_rp_23(PCB_POINTER, l) (l)

#define ag_rp_24(PCB_POINTER, e) (START(expr, e))

#define ag_rp_25(PCB_POINTER, l, e) (ADD(expr, l, e))

#define ag_rp_26(PCB_POINTER, e) (e)

#define ag_rp_27(PCB_POINTER, e, v) (bind_tail_of_path(&PCB, e, v), e)

#define ag_rp_28(PCB_POINTER, v, e) (bind_tail_of_path(&PCB, e, v), e)

#define ag_rp_29(PCB_POINTER, e, v) (MKEXPR(assign, v, e, NULL))

#define ag_rp_30(PCB_POINTER, v, e) (MKEXPR(assign, v, e, NULL))

#define ag_rp_31(PCB_POINTER, e) (e)

#define ag_rp_32(PCB_POINTER, e) (e)

#define ag_rp_33(PCB_POINTER, e) (e)

#define ag_rp_34(PCB_POINTER, v, e, p) (MKEXPR(exists, v, e, p))

#define ag_rp_35(PCB_POINTER, v, e, p) (MKEXPR(forall, v, e, p))

#define ag_rp_36(PCB_POINTER, e) (e)

#define ag_rp_37(PCB_POINTER, l, op, r) (MKEXPR(bop, l, op, r))

#define ag_rp_38(PCB_POINTER) (F_AND)

#define ag_rp_39(PCB_POINTER) (F_OR)

#define ag_rp_40(PCB_POINTER, e) (e)

#define ag_rp_41(PCB_POINTER, l, r) (MKEXPR(bop, l, F_IN, r))

#define ag_rp_42(PCB_POINTER, e) (e)

#define ag_rp_43(PCB_POINTER, l, op, r) (MKEXPR(bop, l, op, r))

#define ag_rp_44(PCB_POINTER) (F_INTERSECT)

#define ag_rp_45(PCB_POINTER) (F_UNION)

#define ag_rp_46(PCB_POINTER) (F_EXCEPT)

#define ag_rp_47(PCB_POINTER) (F_INTERSECTALL)

#define ag_rp_48(PCB_POINTER) (F_UNIONALL)

#define ag_rp_49(PCB_POINTER) (F_EXCEPTALL)

#define ag_rp_50(PCB_POINTER, e) (e)

#define ag_rp_51(PCB_POINTER, l, op, r) (MKEXPR(bop, l, op, r))

#define ag_rp_52(PCB_POINTER, l, op, r) (do_exists_bop(PCB.pql, l, op, r))

#define ag_rp_53(PCB_POINTER, l, op, r) (do_forall_bop(PCB.pql, l, op, r))

#define ag_rp_54(PCB_POINTER) (F_EQ)

#define ag_rp_55(PCB_POINTER) (F_NOTEQ)

#define ag_rp_56(PCB_POINTER) (F_LT)

#define ag_rp_57(PCB_POINTER) (F_LTEQ)

#define ag_rp_58(PCB_POINTER) (F_GTEQ)

#define ag_rp_59(PCB_POINTER) (F_GT)

#define ag_rp_60(PCB_POINTER) (F_LIKE)

#define ag_rp_61(PCB_POINTER) (F_GLOB)

#define ag_rp_62(PCB_POINTER) (F_GREP)

#define ag_rp_63(PCB_POINTER) (F_SOUNDEX)

#define ag_rp_64(PCB_POINTER, e) (e)

#define ag_rp_65(PCB_POINTER, e) (e)

#define ag_rp_66(PCB_POINTER, e) (e)

#define ag_rp_67(PCB_POINTER, l, op, r) (MKEXPR(bop, l, op, r))

#define ag_rp_68(PCB_POINTER) (F_ADD)

#define ag_rp_69(PCB_POINTER) (F_SUB)

#define ag_rp_70(PCB_POINTER) (F_CONCAT)

#define ag_rp_71(PCB_POINTER, e) (e)

#define ag_rp_72(PCB_POINTER, l, op, r) (MKEXPR(bop, l, op, r))

#define ag_rp_73(PCB_POINTER) (F_MUL)

#define ag_rp_74(PCB_POINTER) (F_DIV)

#define ag_rp_75(PCB_POINTER) (F_MOD)

#define ag_rp_76(PCB_POINTER, e) (e)

#define ag_rp_77(PCB_POINTER, e) (e)

#define ag_rp_78(PCB_POINTER, e) (MKEXPR(uop, F_NEG, e))

#define ag_rp_79(PCB_POINTER, e) (MKEXPR(uop, F_NOT, e))

#define ag_rp_80(PCB_POINTER, e) (e)

#define ag_rp_81(PCB_POINTER, p) (MKEXPR(uop, F_TOSTRING, p))

#define ag_rp_82(PCB_POINTER, op, e) (MKEXPR(uop, op, e))

#define ag_rp_83(PCB_POINTER, f, l) (MKEXPR(func, f, l))

#define ag_rp_84(PCB_POINTER, f) (MKEXPR(func, f, NULL))

#define ag_rp_85(PCB_POINTER, l) (MKEXPR(uop, F_NEW, MKEXPR(tuple, l)))

#define ag_rp_86(PCB_POINTER, e) (e)

#define ag_rp_87(PCB_POINTER, e) (e)

#define ag_rp_88(PCB_POINTER, e) (e)

#define ag_rp_89(PCB_POINTER) (F_MIN)

#define ag_rp_90(PCB_POINTER) (F_MAX)

#define ag_rp_91(PCB_POINTER) (F_COUNT)

#define ag_rp_92(PCB_POINTER) (F_SUM)

#define ag_rp_93(PCB_POINTER) (F_AVG)

#define ag_rp_94(PCB_POINTER) (F_ABS)

#define ag_rp_95(PCB_POINTER) (F_NONEMPTY)

#define ag_rp_96(PCB_POINTER) (F_GETELEMENT)

#define ag_rp_97(PCB_POINTER) (F_MAKESET)

#define ag_rp_98(PCB_POINTER, s) (function_getbyname(s.str, s.len))

#define ag_rp_99(PCB_POINTER, e) (START(expr, e))

#define ag_rp_100(PCB_POINTER, l, e) (ADD(expr, l, e))

#define ag_rp_101(PCB_POINTER) (MKEXPR(value, pqlvalue_nil(PCB.pql)))

#define ag_rp_102(PCB_POINTER, x) (MKEXPR(value, getint(PCB.pql, x.str, x.len)))

#define ag_rp_103(PCB_POINTER, x) (MKEXPR(value, getdouble(PCB.pql, x.str, x.len)))

#define ag_rp_104(PCB_POINTER, x) (MKEXPR(value, getstring(PCB.pql, x.str, x.len)))

#define ag_rp_105(PCB_POINTER) (MKEXPR(value, pqlvalue_bool(PCB.pql, true)))

#define ag_rp_106(PCB_POINTER) (MKEXPR(value, pqlvalue_bool(PCB.pql, false)))

#define ag_rp_107(PCB_POINTER, e) (e)

#define ag_rp_108(PCB_POINTER, v, p) (MKEXPR(path, v, p))

#define ag_rp_109(PCB_POINTER, p) (p)

#define ag_rp_110(PCB_POINTER, l, p) (pathseq_add(PCB.pql, l, p))

#define ag_rp_111(PCB_POINTER, p) (p)

#define ag_rp_112(PCB_POINTER, l, p) (pathalt_add(PCB.pql, l, p))

#define ag_rp_113(PCB_POINTER, p) (p)

#define ag_rp_114(PCB_POINTER, p, v) (path_bindobj(&PCB,p,v),p)

#define ag_rp_115(PCB_POINTER, p) (p)

#define ag_rp_116(PCB_POINTER, p, v) (path_bindpath(&PCB, p, v), p)

#define ag_rp_117(PCB_POINTER, p) (p)

#define ag_rp_118(PCB_POINTER, p) (MKPATH(optional, MKPATH(repeated, p)))

#define ag_rp_119(PCB_POINTER, p) (MKPATH(repeated, p))

#define ag_rp_120(PCB_POINTER, p) (MKPATH(optional, p))

#define ag_rp_121(PCB_POINTER, p) (p)

#define ag_rp_122(PCB_POINTER, p) (p->parens = true, p)

static struct ptpath * ag_rp_123(PCB_DECL) {
#line 384 "/home/vfiler/dholland/projects/pql/hg/rehacking/libpql/ptparse.syn"
 return MKPATH(optional,
			    MKPATH(repeated,
				   MKPATH(staticedge, "%", 1, false/*rev*/)));
            
#line 892 "ptparse.c"
}

#define ag_rp_124(PCB_POINTER, x) (MKPATH(staticedge, x.str, x.len, false/*rev*/))

#define ag_rp_125(PCB_POINTER, x) (MKPATH(staticedge, x.str, x.len, true/*rev*/))

#define ag_rp_126(PCB_POINTER, e) (MKPATH(computededge, e, false/*rev*/))

#define ag_rp_127(PCB_POINTER, e) (e)

#define ag_rp_128(PCB_POINTER, e) (e)

#define ag_rp_129(PCB_POINTER, x) (MKEXPR(readanyvar, PCB.line, PCB.column, x.str, x.len))

#define ag_rp_130(PCB_POINTER, x) (mkptcolumnvar(PCB.pql, PCB.line, PCB.column, x.str, x.len))


#define READ_COUNTS 
#define WRITE_COUNTS 
#undef V
#define V(i,t) (*t (&(PCB).vs[(PCB).ssx + i]))
#undef VS
#define VS(i) (PCB).vs[(PCB).ssx + i]

#ifndef GET_CONTEXT
#define GET_CONTEXT CONTEXT = (PCB).input_context
#endif

typedef enum {
  ag_action_1,
  ag_action_2,
  ag_action_3,
  ag_action_4,
  ag_action_5,
  ag_action_6,
  ag_action_7,
  ag_action_8,
  ag_action_9,
  ag_action_10,
  ag_action_11,
  ag_action_12
} ag_parser_action;


#ifndef NULL_VALUE_INITIALIZER
#define NULL_VALUE_INITIALIZER = { 0 }
#endif

static ptparse_vs_type const ag_null_value NULL_VALUE_INITIALIZER;

static const unsigned char ag_rpx[] = {
    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,  0,  0, 27, 28, 29, 30, 31,
   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
   50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
   68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
   86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,
  104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
  122,123,124,125,126,127,128,129,130
};
#define AG_TCV(x) (((int)(x) >= 0 && (int)(x) <= 255) ? ag_tcv[(x)] : 0)

static const unsigned char ag_tcv[] = {
    5,110, 28, 22,113, 55, 60, 59,115,107,118, 36, 57, 58, 56, 69,105, 68,
   70,112,108,119, 37,  3, 74, 73, 91, 41, 44, 54, 25, 90, 17, 88, 23, 92,
   51, 39,100, 40, 29, 62, 63, 16, 15, 34, 49, 61, 87, 86, 75, 84, 95, 77,
  116, 45, 79,  8, 93, 54, 64, 89, 99, 21, 50,117, 13, 19, 26, 96, 98, 97,
   94,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0
};

#ifndef SYNTAX_ERROR
#define SYNTAX_ERROR fprintf(stderr,"%s, line %d, column %d\n", \
  (PCB).error_message, (PCB).line, (PCB).column)
#endif

#ifndef FIRST_LINE
#define FIRST_LINE 1
#endif

#ifndef FIRST_COLUMN
#define FIRST_COLUMN 1
#endif

#ifndef PARSER_STACK_OVERFLOW
#define PARSER_STACK_OVERFLOW {fprintf(stderr, \
   "\nParser stack overflow, line %d, column %d\n",\
   (PCB).line, (PCB).column);}
#endif

#ifndef REDUCTION_TOKEN_ERROR
#define REDUCTION_TOKEN_ERROR {fprintf(stderr, \
    "\nReduction token error, line %d, column %d\n", \
    (PCB).line, (PCB).column);}
#endif


#ifndef AG_NEWLINE
#define AG_NEWLINE 10
#endif

#ifndef AG_RETURN
#define AG_RETURN 13
#endif

#ifndef AG_FORMFEED
#define AG_FORMFEED 12
#endif

#ifndef AG_TABCHAR
#define AG_TABCHAR 9
#endif

static void ag_track(PCB_DECL) {
  switch ((PCB).input_code) {
  case AG_NEWLINE:
    (PCB).column = 1, (PCB).line++;
  case AG_RETURN:
  case AG_FORMFEED:
    break;
  case AG_TABCHAR:
    (PCB).column += (TAB_SPACING) - ((PCB).column - 1) % (TAB_SPACING);
    break;
  default:
    (PCB).column++;
  }
  (PCB).read_flag = 1;
}


static void ag_prot(PCB_DECL) {
  int ag_k;
  ag_k = 128 - ++(PCB).btsx;
  if (ag_k <= (PCB).ssx) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
    return;
  }
  (PCB).bts[(PCB).btsx] = (PCB).sn;
  (PCB).bts[ag_k] = (PCB).ssx;
  (PCB).vs[ag_k] = (PCB).vs[(PCB).ssx];
  (PCB).ss[ag_k] = (PCB).ss[(PCB).ssx];
}

static void ag_undo(PCB_DECL) {
  if ((PCB).drt == -1) return;
  while ((PCB).btsx) {
    int ag_k = 128 - (PCB).btsx;
    (PCB).sn = (PCB).bts[(PCB).btsx--];
    (PCB).ssx = (PCB).bts[ag_k];
    (PCB).vs[(PCB).ssx] = (PCB).vs[ag_k];
    (PCB).ss[(PCB).ssx] = (PCB).ss[ag_k];
  }
  (PCB).token_number = (ptparse_token_type) (PCB).drt;
  (PCB).ssx = (PCB).dssx;
  (PCB).sn = (PCB).dsn;
  (PCB).drt = -1;
}


static const unsigned char ag_tstt[] = {
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,8,
  0,1,2,6,7,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,8,
  0,2,6,7,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
36,0,
36,0,
36,0,
36,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,71,
  76,78,80,81,82,85,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,71,
  76,78,80,81,82,85,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,71,
  76,78,80,81,82,85,
113,36,0,102,103,104,106,109,111,
75,74,73,0,72,
70,69,68,0,67,
64,63,62,61,60,59,58,57,56,55,0,53,
51,50,49,0,48,
34,0,
41,0,
26,0,20,
45,44,0,43,
118,117,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,
  36,26,23,0,9,
5,3,0,4,
37,0,
118,117,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,
  36,26,0,6,10,14,24,27,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,37,36,26,
  0,6,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,83,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,8,
  0,2,6,7,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
26,0,80,
113,36,0,102,103,104,106,109,111,
118,117,115,26,0,27,114,
112,73,68,0,
110,0,
107,0,
105,0,
113,36,0,103,104,106,109,111,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,71,
  76,78,80,81,82,85,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,66,
  71,76,78,80,81,82,85,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,54,41,39,36,26,
  0,32,52,65,66,71,76,78,80,81,82,85,101,
41,0,
41,0,
41,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,32,
  47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,32,
  46,47,52,65,66,71,76,78,80,81,82,85,101,
26,0,20,
34,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,32,
  42,46,47,52,65,66,71,76,78,80,81,82,85,101,
118,117,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,
  36,26,0,6,10,14,24,27,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
5,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,8,
  0,2,6,7,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
36,0,
28,0,
28,0,
25,0,
37,22,0,
37,22,0,
37,0,
37,0,
113,37,36,0,103,104,106,109,111,
69,0,
26,0,20,
26,0,20,
113,36,0,104,106,109,111,
105,0,
75,74,73,0,72,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,32,
  52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,39,36,26,0,32,
  52,65,66,71,76,78,80,81,82,85,101,
64,63,62,61,60,59,58,57,56,55,0,53,
51,50,49,0,48,
34,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
34,0,
119,37,29,22,21,16,15,13,5,3,0,11,12,
119,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,8,
  0,2,6,7,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  6,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  6,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
118,117,26,0,27,
118,117,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,
  36,26,0,6,14,24,27,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  6,14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
116,0,
108,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
28,0,
36,26,0,20,30,31,32,35,80,101,
21,16,15,13,0,
37,0,
28,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
113,36,0,102,103,104,106,109,111,
8,0,7,
113,36,34,0,
26,25,0,33,
34,0,
119,37,26,25,22,21,16,15,13,5,3,0,33,
22,0,
26,0,20,
17,0,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,84,79,77,73,69,40,39,36,26,0,
  14,32,38,42,46,47,52,65,66,71,76,78,80,81,82,85,101,
37,0,
26,0,20,
36,26,0,32,35,80,101,
26,0,20,
36,26,0,20,31,32,35,80,101,
26,0,18,20,
22,19,0,
26,0,20,
26,0,20,
  0
};


static unsigned const char ag_astt[1515] = {
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,1,7,0,1,2,2,2,2,1,1,1,1,2,
  1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,1,7,1,
  2,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,7,1,7,1,7,1,7,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
  1,1,1,1,2,1,2,7,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,
  2,7,2,2,2,2,1,1,2,1,1,4,1,1,2,1,1,1,2,2,2,4,1,2,2,2,4,1,2,2,2,2,2,2,2,2,2,
  2,4,1,1,1,1,4,1,1,4,1,7,2,4,1,2,2,4,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  4,4,4,4,4,4,4,4,2,7,1,8,1,7,1,2,7,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,
  1,1,1,1,1,1,7,1,1,2,2,1,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,2,2,1,1,1,1,1,1,1,2,1,2,7,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,1,2,2,2,
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,1,7,1,2,2,2,2,1,1,1,1,2,1,1,
  2,2,2,1,1,1,2,2,2,7,1,1,1,7,1,1,2,1,1,1,1,1,2,1,7,2,2,2,2,2,4,1,4,1,4,1,4,
  1,1,4,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,2,2,2,1,
  1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,1,2,2,2,2,1,1,2,2,2,2,
  2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,1,2,7,2,2,1,1,2,2,2,1,1,1,2,2,2,4,
  2,4,2,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,1,2,1,1,2,2,2,1,
  1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,1,1,2,1,1,2,2,2,
  1,1,1,2,2,2,7,1,1,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,1,1,
  1,2,1,1,2,2,2,1,1,1,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
  1,7,1,1,2,2,1,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,7,2,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,1,1,1,1,1,1,1,1,2,1,7,1,2,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,7,1,
  7,1,4,1,4,2,1,7,2,1,7,2,7,2,7,1,2,1,7,1,2,1,1,1,1,4,2,7,2,2,7,1,1,1,7,2,1,
  1,1,1,4,2,2,2,4,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,2,1,1,
  2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,2,7,2,2,1,1,2,
  2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,4,1,1,1,1,4,1,1,7,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,1,1,1,1,1,1,1,1,2,7,1,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,4,4,4,1,1,
  4,4,4,4,4,4,7,1,2,2,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,1,7,
  1,2,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
  1,1,1,1,1,1,2,7,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,1,1,1,1,1,1,1,1,2,7,2,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,1,2,7,2,
  1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,7,1,2,2,1,2,1,1,1,1,2,
  1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,7,2,2,
  2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,7,2,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
  1,1,1,1,1,1,2,7,1,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,7,1,1,7,1,1,2,1,1,1,2,
  1,1,1,1,4,2,7,1,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,7,2,2,1,
  1,1,1,2,1,1,2,2,2,1,1,1,2,2,1,1,7,1,1,2,1,1,1,1,7,1,4,4,4,7,8,1,7,1,1,7,4,
  4,8,1,4,4,4,4,4,4,4,7,1,1,4,2,7,2,1,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,
  1,1,1,1,1,2,7,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
  2,2,1,1,1,1,1,1,1,1,2,7,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,7,2,2,1,1,1,1,2,1,1,2,2,2,1,1,1,2,2,2,7,2,
  7,2,1,2,7,2,2,1,2,2,7,2,1,1,7,1,2,1,1,1,2,2,7,1,2,1,1,4,2,7,2,2,7,2,11
};


static const unsigned char ag_pstt[] = {
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  18,0,0,19,4,5,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  18,1,20,4,5,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
21,2,
22,3,
23,4,
24,5,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,6,
  83,80,84,91,4,3,90,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,7,
  82,80,84,91,4,3,90,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,8,
  81,80,84,91,4,3,90,
26,25,91,31,30,115,29,28,27,
79,78,77,70,32,
74,73,72,69,33,
67,66,65,64,63,62,61,60,59,58,46,34,
35,36,37,44,38,
39,40,
40,15,
134,99,41,
43,42,37,42,
15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
  15,16,18,43,
44,44,19,44,
92,20,
45,46,110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,
  1,48,21,49,50,36,17,47,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,88,1,
  133,22,103,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,51,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  18,23,52,4,5,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
133,24,53,
26,25,25,54,30,115,29,28,27,
45,46,127,55,26,130,125,
124,122,123,121,
56,119,
57,117,
58,113,
26,25,112,59,115,29,28,27,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,32,
  76,80,84,91,4,3,90,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,33,
  60,75,80,84,91,4,3,90,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,62,61,99,1,
  133,34,68,55,11,10,75,80,84,9,4,3,90,111,
53,50,
52,49,
51,48,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,38,
  68,63,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,39,
  68,64,12,54,11,10,75,80,84,9,4,3,90,111,
134,40,65,
66,41,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,42,
  68,67,13,12,54,11,10,75,80,84,9,4,3,90,111,
45,46,110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,
  1,48,43,49,68,36,17,47,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
3,44,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  18,45,69,4,5,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
70,46,
71,47,
72,133,
73,19,
89,74,50,
87,75,51,
86,52,
85,53,
26,126,25,54,59,115,29,28,27,
76,128,
134,56,120,
134,57,77,
26,25,58,116,29,28,27,
58,114,
79,78,77,71,32,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,61,
  68,57,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,99,1,133,62,
  68,56,11,10,75,80,84,9,4,3,90,111,
67,66,65,64,63,62,61,60,59,58,47,34,
35,36,37,45,38,
78,65,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  66,79,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
39,41,
24,24,80,74,24,24,24,24,24,24,68,81,7,
132,69,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  18,70,82,4,5,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  71,23,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  72,22,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
45,46,20,73,21,
45,46,110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,
  1,48,74,49,36,18,47,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  75,104,36,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
129,76,
118,77,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  78,83,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
84,79,
86,87,80,89,91,26,90,88,85,111,
92,93,94,95,6,
131,82,
96,83,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  84,38,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
26,25,85,31,30,115,29,28,27,
18,86,97,
133,133,134,87,
98,98,88,98,
99,89,
28,28,100,100,28,28,28,28,28,28,28,90,100,
101,25,
134,92,12,
102,93,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  94,9,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  95,8,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
110,109,108,107,106,105,102,101,100,98,97,96,95,94,93,2,5,6,8,7,15,16,1,133,
  96,39,68,17,14,13,12,54,11,10,75,80,84,9,4,3,90,111,
35,97,
134,98,33,
86,133,99,32,34,85,111,
134,100,31,
86,87,101,89,27,90,88,85,111,
134,102,103,13,
104,105,10,
134,104,14,
134,105,11,
  0
};


static const unsigned short ag_sbt[] = {
     0,  47,  93,  95,  97,  99, 101, 132, 163, 194, 203, 208, 213, 225,
   230, 232, 234, 237, 241, 270, 274, 276, 324, 369, 415, 418, 427, 434,
   438, 440, 442, 444, 452, 483, 515, 553, 555, 557, 559, 596, 634, 637,
   639, 678, 726, 728, 774, 776, 778, 780, 782, 785, 788, 790, 792, 801,
   803, 806, 809, 816, 818, 823, 859, 895, 907, 912, 914, 956, 958, 971,
   973,1019,1062,1105,1110,1157,1200,1202,1204,1246,1248,1258,1263,1265,
  1267,1309,1318,1321,1325,1329,1331,1344,1346,1349,1351,1393,1435,1477,
  1479,1482,1489,1492,1501,1505,1508,1511,1514
};


static const unsigned short ag_sbe[] = {
    25,  72,  94,  96,  98, 100, 124, 155, 186, 196, 206, 211, 223, 228,
   231, 233, 235, 239, 268, 272, 275, 302, 349, 394, 416, 420, 431, 437,
   439, 441, 443, 446, 475, 506, 540, 554, 556, 558, 582, 619, 635, 638,
   662, 704, 727, 753, 775, 777, 779, 781, 784, 787, 789, 791, 795, 802,
   804, 807, 811, 817, 821, 846, 882, 905, 910, 913, 938, 957, 968, 972,
   998,1043,1086,1108,1136,1181,1201,1203,1228,1247,1250,1262,1264,1266,
  1291,1311,1319,1324,1327,1330,1342,1345,1347,1350,1375,1417,1459,1478,
  1480,1484,1490,1494,1502,1507,1509,1512,1514
};


static const unsigned char ag_fl[] = {
  1,0,1,3,1,1,4,1,3,3,4,6,3,1,3,0,1,1,3,1,3,3,3,3,0,2,1,3,1,0,1,3,3,3,3,
  3,1,1,6,7,1,3,1,1,1,3,1,3,1,1,1,2,2,2,1,3,4,4,1,1,1,1,1,1,1,1,1,1,1,1,
  1,3,1,1,1,1,3,1,1,1,1,2,2,2,1,4,4,4,3,4,1,1,3,1,1,1,1,1,1,1,1,1,1,1,3,
  1,1,1,1,1,1,1,2,1,2,1,3,1,4,1,3,1,2,2,2,2,3,1,1,3,1,4,3,1,1
};

static const unsigned char ag_ptt[] = {
    0,  4,  4,  1,  2,  2,  7, 11, 11, 11, 11, 11, 11, 18, 18,  9,  9, 10,
   10, 24, 24, 24, 24, 24, 12, 12, 30, 30, 31, 33, 33, 31, 31, 31, 31, 35,
    6, 14, 14, 14, 38, 38, 43, 43, 42, 42, 46, 46, 48, 48, 48, 48, 48, 48,
   47, 47, 47, 47, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 52, 52, 65, 65,
   67, 67, 67, 66, 66, 72, 72, 72, 71, 71, 71, 71, 76, 78, 78, 78, 78, 78,
   78, 78, 78, 81, 81, 81, 81, 81, 81, 81, 81, 81, 82, 83, 83, 85, 85, 85,
   85, 85, 85, 32,101,102,102,103,103,104,104,106,106,109,109,109,109,111,
  111,114,114,114,114, 27, 27, 80, 20
};


static void ag_ra(PCB_DECL)
{
  switch(ag_rpx[(PCB).ag_ap]) {
    case 1: ag_rp_1(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 2: V(0,(struct ptexpr * *)) = ag_rp_2(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 3: V(0,(struct ptexpr * *)) = ag_rp_3(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 4: V(0,(struct ptexpr * *)) = ag_rp_4(PCB_POINTER, V(1,(bool *)), V(2,(struct ptexprarray * *)), V(3,(struct ptexpr * *))); break;
    case 5: V(0,(struct ptexpr * *)) = ag_rp_5(PCB_POINTER, V(0,(struct ptexprarray * *))); break;
    case 6: V(0,(struct ptexpr * *)) = ag_rp_6(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptexpr * *))); break;
    case 7: V(0,(struct ptexpr * *)) = ag_rp_7(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptexpr * *))); break;
    case 8: V(0,(struct ptexpr * *)) = ag_rp_8(PCB_POINTER, V(0,(struct ptexpr * *)), V(3,(struct ptcolumnvararray * *))); break;
    case 9: V(0,(struct ptexpr * *)) = ag_rp_9(PCB_POINTER, V(0,(struct ptexpr * *)), V(3,(struct ptcolumnvararray * *)), V(5,(struct ptcolumnvar * *))); break;
    case 10: V(0,(struct ptexpr * *)) = ag_rp_10(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptcolumnvar * *))); break;
    case 11: V(0,(struct ptcolumnvararray * *)) = ag_rp_11(PCB_POINTER, V(0,(struct ptcolumnvar * *))); break;
    case 12: V(0,(struct ptcolumnvararray * *)) = ag_rp_12(PCB_POINTER, V(0,(struct ptcolumnvararray * *)), V(2,(struct ptcolumnvar * *))); break;
    case 13: V(0,(bool *)) = ag_rp_13(PCB_POINTER); break;
    case 14: V(0,(bool *)) = ag_rp_14(PCB_POINTER); break;
    case 15: V(0,(struct ptexprarray * *)) = ag_rp_15(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 16: V(0,(struct ptexprarray * *)) = ag_rp_16(PCB_POINTER, V(0,(struct ptexprarray * *)), V(2,(struct ptexpr * *))); break;
    case 17: V(0,(struct ptexpr * *)) = ag_rp_17(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 18: V(0,(struct ptexpr * *)) = ag_rp_18(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct tokstr *))); break;
    case 19: V(0,(struct ptexpr * *)) = ag_rp_19(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptexpr * *))); break;
    case 20: V(0,(struct ptexpr * *)) = ag_rp_20(PCB_POINTER, V(0,(struct tokstr *)), V(2,(struct ptexpr * *))); break;
    case 21: V(0,(struct ptexpr * *)) = ag_rp_21(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptexpr * *))); break;
    case 22: V(0,(struct ptexprarray * *)) = ag_rp_22(PCB_POINTER); break;
    case 23: V(0,(struct ptexprarray * *)) = ag_rp_23(PCB_POINTER, V(1,(struct ptexprarray * *))); break;
    case 24: V(0,(struct ptexprarray * *)) = ag_rp_24(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 25: V(0,(struct ptexprarray * *)) = ag_rp_25(PCB_POINTER, V(0,(struct ptexprarray * *)), V(2,(struct ptexpr * *))); break;
    case 26: V(0,(struct ptexpr * *)) = ag_rp_26(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 27: V(0,(struct ptexpr * *)) = ag_rp_27(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptcolumnvar * *))); break;
    case 28: V(0,(struct ptexpr * *)) = ag_rp_28(PCB_POINTER, V(0,(struct ptcolumnvar * *)), V(2,(struct ptexpr * *))); break;
    case 29: V(0,(struct ptexpr * *)) = ag_rp_29(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptcolumnvar * *))); break;
    case 30: V(0,(struct ptexpr * *)) = ag_rp_30(PCB_POINTER, V(0,(struct ptcolumnvar * *)), V(2,(struct ptexpr * *))); break;
    case 31: V(0,(struct ptexpr * *)) = ag_rp_31(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 32: V(0,(struct ptexpr * *)) = ag_rp_32(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 33: V(0,(struct ptexpr * *)) = ag_rp_33(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 34: V(0,(struct ptexpr * *)) = ag_rp_34(PCB_POINTER, V(1,(struct ptcolumnvar * *)), V(3,(struct ptexpr * *)), V(5,(struct ptexpr * *))); break;
    case 35: V(0,(struct ptexpr * *)) = ag_rp_35(PCB_POINTER, V(2,(struct ptcolumnvar * *)), V(4,(struct ptexpr * *)), V(6,(struct ptexpr * *))); break;
    case 36: V(0,(struct ptexpr * *)) = ag_rp_36(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 37: V(0,(struct ptexpr * *)) = ag_rp_37(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 38: V(0,(enum functions *)) = ag_rp_38(PCB_POINTER); break;
    case 39: V(0,(enum functions *)) = ag_rp_39(PCB_POINTER); break;
    case 40: V(0,(struct ptexpr * *)) = ag_rp_40(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 41: V(0,(struct ptexpr * *)) = ag_rp_41(PCB_POINTER, V(0,(struct ptexpr * *)), V(2,(struct ptexpr * *))); break;
    case 42: V(0,(struct ptexpr * *)) = ag_rp_42(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 43: V(0,(struct ptexpr * *)) = ag_rp_43(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 44: V(0,(enum functions *)) = ag_rp_44(PCB_POINTER); break;
    case 45: V(0,(enum functions *)) = ag_rp_45(PCB_POINTER); break;
    case 46: V(0,(enum functions *)) = ag_rp_46(PCB_POINTER); break;
    case 47: V(0,(enum functions *)) = ag_rp_47(PCB_POINTER); break;
    case 48: V(0,(enum functions *)) = ag_rp_48(PCB_POINTER); break;
    case 49: V(0,(enum functions *)) = ag_rp_49(PCB_POINTER); break;
    case 50: V(0,(struct ptexpr * *)) = ag_rp_50(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 51: V(0,(struct ptexpr * *)) = ag_rp_51(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 52: V(0,(struct ptexpr * *)) = ag_rp_52(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(3,(struct ptexpr * *))); break;
    case 53: V(0,(struct ptexpr * *)) = ag_rp_53(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(3,(struct ptexpr * *))); break;
    case 54: V(0,(enum functions *)) = ag_rp_54(PCB_POINTER); break;
    case 55: V(0,(enum functions *)) = ag_rp_55(PCB_POINTER); break;
    case 56: V(0,(enum functions *)) = ag_rp_56(PCB_POINTER); break;
    case 57: V(0,(enum functions *)) = ag_rp_57(PCB_POINTER); break;
    case 58: V(0,(enum functions *)) = ag_rp_58(PCB_POINTER); break;
    case 59: V(0,(enum functions *)) = ag_rp_59(PCB_POINTER); break;
    case 60: V(0,(enum functions *)) = ag_rp_60(PCB_POINTER); break;
    case 61: V(0,(enum functions *)) = ag_rp_61(PCB_POINTER); break;
    case 62: V(0,(enum functions *)) = ag_rp_62(PCB_POINTER); break;
    case 63: V(0,(enum functions *)) = ag_rp_63(PCB_POINTER); break;
    case 64: V(0,(struct ptexpr * *)) = ag_rp_64(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 65: V(0,(struct ptexpr * *)) = ag_rp_65(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 66: V(0,(struct ptexpr * *)) = ag_rp_66(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 67: V(0,(struct ptexpr * *)) = ag_rp_67(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 68: V(0,(enum functions *)) = ag_rp_68(PCB_POINTER); break;
    case 69: V(0,(enum functions *)) = ag_rp_69(PCB_POINTER); break;
    case 70: V(0,(enum functions *)) = ag_rp_70(PCB_POINTER); break;
    case 71: V(0,(struct ptexpr * *)) = ag_rp_71(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 72: V(0,(struct ptexpr * *)) = ag_rp_72(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 73: V(0,(enum functions *)) = ag_rp_73(PCB_POINTER); break;
    case 74: V(0,(enum functions *)) = ag_rp_74(PCB_POINTER); break;
    case 75: V(0,(enum functions *)) = ag_rp_75(PCB_POINTER); break;
    case 76: V(0,(struct ptexpr * *)) = ag_rp_76(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 77: V(0,(struct ptexpr * *)) = ag_rp_77(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 78: V(0,(struct ptexpr * *)) = ag_rp_78(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 79: V(0,(struct ptexpr * *)) = ag_rp_79(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 80: V(0,(struct ptexpr * *)) = ag_rp_80(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 81: V(0,(struct ptexpr * *)) = ag_rp_81(PCB_POINTER, V(2,(struct ptexpr * *))); break;
    case 82: V(0,(struct ptexpr * *)) = ag_rp_82(PCB_POINTER, V(0,(enum functions *)), V(2,(struct ptexpr * *))); break;
    case 83: V(0,(struct ptexpr * *)) = ag_rp_83(PCB_POINTER, V(0,(enum functions *)), V(2,(struct ptexprarray * *))); break;
    case 84: V(0,(struct ptexpr * *)) = ag_rp_84(PCB_POINTER, V(0,(enum functions *))); break;
    case 85: V(0,(struct ptexpr * *)) = ag_rp_85(PCB_POINTER, V(2,(struct ptexprarray * *))); break;
    case 86: V(0,(struct ptexpr * *)) = ag_rp_86(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 87: V(0,(struct ptexpr * *)) = ag_rp_87(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 88: V(0,(struct ptexpr * *)) = ag_rp_88(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 89: V(0,(enum functions *)) = ag_rp_89(PCB_POINTER); break;
    case 90: V(0,(enum functions *)) = ag_rp_90(PCB_POINTER); break;
    case 91: V(0,(enum functions *)) = ag_rp_91(PCB_POINTER); break;
    case 92: V(0,(enum functions *)) = ag_rp_92(PCB_POINTER); break;
    case 93: V(0,(enum functions *)) = ag_rp_93(PCB_POINTER); break;
    case 94: V(0,(enum functions *)) = ag_rp_94(PCB_POINTER); break;
    case 95: V(0,(enum functions *)) = ag_rp_95(PCB_POINTER); break;
    case 96: V(0,(enum functions *)) = ag_rp_96(PCB_POINTER); break;
    case 97: V(0,(enum functions *)) = ag_rp_97(PCB_POINTER); break;
    case 98: V(0,(enum functions *)) = ag_rp_98(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 99: V(0,(struct ptexprarray * *)) = ag_rp_99(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 100: V(0,(struct ptexprarray * *)) = ag_rp_100(PCB_POINTER, V(0,(struct ptexprarray * *)), V(2,(struct ptexpr * *))); break;
    case 101: V(0,(struct ptexpr * *)) = ag_rp_101(PCB_POINTER); break;
    case 102: V(0,(struct ptexpr * *)) = ag_rp_102(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 103: V(0,(struct ptexpr * *)) = ag_rp_103(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 104: V(0,(struct ptexpr * *)) = ag_rp_104(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 105: V(0,(struct ptexpr * *)) = ag_rp_105(PCB_POINTER); break;
    case 106: V(0,(struct ptexpr * *)) = ag_rp_106(PCB_POINTER); break;
    case 107: V(0,(struct ptexpr * *)) = ag_rp_107(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 108: V(0,(struct ptexpr * *)) = ag_rp_108(PCB_POINTER, V(0,(struct ptexpr * *)), V(1,(struct ptpath * *))); break;
    case 109: V(0,(struct ptpath * *)) = ag_rp_109(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 110: V(0,(struct ptpath * *)) = ag_rp_110(PCB_POINTER, V(0,(struct ptpath * *)), V(1,(struct ptpath * *))); break;
    case 111: V(0,(struct ptpath * *)) = ag_rp_111(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 112: V(0,(struct ptpath * *)) = ag_rp_112(PCB_POINTER, V(0,(struct ptpath * *)), V(2,(struct ptpath * *))); break;
    case 113: V(0,(struct ptpath * *)) = ag_rp_113(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 114: V(0,(struct ptpath * *)) = ag_rp_114(PCB_POINTER, V(0,(struct ptpath * *)), V(2,(struct ptcolumnvar * *))); break;
    case 115: V(0,(struct ptpath * *)) = ag_rp_115(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 116: V(0,(struct ptpath * *)) = ag_rp_116(PCB_POINTER, V(0,(struct ptpath * *)), V(2,(struct ptcolumnvar * *))); break;
    case 117: V(0,(struct ptpath * *)) = ag_rp_117(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 118: V(0,(struct ptpath * *)) = ag_rp_118(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 119: V(0,(struct ptpath * *)) = ag_rp_119(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 120: V(0,(struct ptpath * *)) = ag_rp_120(PCB_POINTER, V(0,(struct ptpath * *))); break;
    case 121: V(0,(struct ptpath * *)) = ag_rp_121(PCB_POINTER, V(1,(struct ptpath * *))); break;
    case 122: V(0,(struct ptpath * *)) = ag_rp_122(PCB_POINTER, V(1,(struct ptpath * *))); break;
    case 123: V(0,(struct ptpath * *)) = ag_rp_123(PCB_POINTER); break;
    case 124: V(0,(struct ptpath * *)) = ag_rp_124(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 125: V(0,(struct ptpath * *)) = ag_rp_125(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 126: V(0,(struct ptpath * *)) = ag_rp_126(PCB_POINTER, V(0,(struct ptexpr * *))); break;
    case 127: V(0,(struct ptexpr * *)) = ag_rp_127(PCB_POINTER, V(2,(struct ptexpr * *))); break;
    case 128: V(0,(struct ptexpr * *)) = ag_rp_128(PCB_POINTER, V(1,(struct ptexpr * *))); break;
    case 129: V(0,(struct ptexpr * *)) = ag_rp_129(PCB_POINTER, V(0,(struct tokstr *))); break;
    case 130: V(0,(struct ptcolumnvar * *)) = ag_rp_130(PCB_POINTER, V(0,(struct tokstr *))); break;
  }
}

#define TOKEN_NAMES ptparse_token_names
const char *const ptparse_token_names[120] = {
  "complete query",
  "complete query",
  "query",
  "SEMIC",
  "",
  "eof",
  "nonsfw query",
  "sfw query",
  "SELECT",
  "distinct",
  "selection list",
  "sfw body",
  "from list",
  "WHERE",
  "quantified expression",
  "HAVING",
  "GROUP",
  "BY",
  "columnvar list",
  "WITH",
  "columnvar",
  "UNGROUP",
  "COMMA",
  "DISTINCT",
  "selection",
  "AS",
  "IDENTIFIER",
  "unquote",
  "COLON",
  "FROM",
  "from item list",
  "from item",
  "path",
  "",
  "IN",
  "nested sfw",
  "LPAREN",
  "RPAREN",
  "logical expression",
  "EXISTS",
  "FOR",
  "ALL",
  "element expression",
  "logical op",
  "AND",
  "OR",
  "set expression",
  "comparison expression",
  "set op",
  "INTERSECT",
  "UNION",
  "EXCEPT",
  "path or term",
  "comparison op",
  "",
  "EQ",
  "LTGT",
  "LT",
  "LTEQ",
  "GTEQ",
  "GT",
  "LIKE",
  "GLOB",
  "GREP",
  "SOUNDEX",
  "term",
  "factor",
  "add op",
  "PLUS",
  "MINUS",
  "PLUSPLUS",
  "prefix expression",
  "mul op",
  "STAR",
  "SLASH",
  "MOD",
  "suffix expression",
  "NOT",
  "base expression",
  "PATHOF",
  "anyvar",
  "func",
  "function name",
  "query list",
  "NEW",
  "constant",
  "MIN",
  "MAX",
  "COUNT",
  "SUM",
  "AVG",
  "ABS",
  "ELEMENT",
  "SET",
  "FUNCNAME",
  "NIL",
  "INTEGER_LITERAL",
  "REAL_LITERAL",
  "QUOTED_STRING_LITERAL",
  "TRUE",
  "FALSE",
  "top sequential path",
  "sequential path",
  "alternative path",
  "varbinding path",
  "PIPE",
  "pathbinding path",
  "LBRACE",
  "RBRACE",
  "repetition path",
  "AT",
  "base path",
  "QUES",
  "DOT",
  "label",
  "HASH",
  "OF",
  "UNQUOTE",
  "LBRACKBRACK",
  "RBRACKBRACK",

};


static const unsigned char ag_ctn[] = {
    0,0, 78,1, 78,1, 78,1, 78,1, 78,1, 71,1, 71,1, 71,1,101,1, 66,1, 65,1,
   47,1, 46,1, 42,1, 14,1, 14,1, 38,1,  7,1,  0,0, 78,2, 78,2, 78,2, 78,2,
   78,2,111,1,111,1,109,1,106,1,104,1,103,1,102,1, 66,2, 65,2, 47,2, 48,1,
   48,1, 48,1, 46,2, 42,2, 14,2, 14,2, 38,2,  7,2,  0,0, 27,1, 27,1, 24,1,
   24,1, 24,1, 10,1, 83,1, 78,3, 78,3,102,1,114,1,106,2,104,2,103,2,103,1,
   66,1, 47,3, 47,3, 47,1, 46,1, 14,3, 14,3, 42,1, 10,1, 27,2, 27,2, 24,2,
   24,2, 24,2, 10,2, 83,2,114,2,104,3, 14,4, 14,4, 12,1, 11,1, 27,3, 14,5,
   14,5,101,1, 35,1,  0,0, 31,1, 31,1, 31,1, 30,1, 11,2, 11,2, 11,2, 11,2,
   14,6, 35,2, 31,2, 31,2, 31,2, 30,2, 11,3, 18,1, 18,2, 11,5
};

#ifndef MISSING_FORMAT
#define MISSING_FORMAT "Missing %s"
#endif
#ifndef UNEXPECTED_FORMAT
#define UNEXPECTED_FORMAT "Unexpected %s"
#endif
#ifndef UNNAMED_TOKEN
#define UNNAMED_TOKEN "input"
#endif


static void ag_diagnose(PCB_DECL) {
  int ag_snd = (PCB).sn;
  const  char *ag_p;
  int ag_k = ag_sbt[ag_snd];

  if (*(ag_p = TOKEN_NAMES[ag_tstt[ag_k++]]) != 0 &&
            ag_astt[ag_k] == ag_action_8) {
    sprintf((PCB).ag_msg, MISSING_FORMAT, ag_p);
  }
  else if ((ag_k = (int) ag_sbe[(PCB).sn] + 1) == (int) ag_sbt[(PCB).sn+1] - 1
          && *TOKEN_NAMES[ag_tstt[ag_k]]) {
    sprintf((PCB).ag_msg, MISSING_FORMAT, TOKEN_NAMES[ag_tstt[ag_k]]);
  }
  else {
    ag_p = TOKEN_NAMES[(PCB).token_number];
    if ((PCB).token_number == 0 || *ag_p == 0) ag_p = UNNAMED_TOKEN;
    sprintf((PCB).ag_msg, UNEXPECTED_FORMAT, ag_p);

  }
  (PCB).error_message = (PCB).ag_msg;


}
static int ag_action_1_r_proc(PCB_DECL);
static int ag_action_2_r_proc(PCB_DECL);
static int ag_action_3_r_proc(PCB_DECL);
static int ag_action_4_r_proc(PCB_DECL);
static int ag_action_1_s_proc(PCB_DECL);
static int ag_action_3_s_proc(PCB_DECL);
static int ag_action_1_proc(PCB_DECL);
static int ag_action_2_proc(PCB_DECL);
static int ag_action_3_proc(PCB_DECL);
static int ag_action_4_proc(PCB_DECL);
static int ag_action_5_proc(PCB_DECL);
static int ag_action_6_proc(PCB_DECL);
static int ag_action_7_proc(PCB_DECL);
static int ag_action_8_proc(PCB_DECL);
static int ag_action_9_proc(PCB_DECL);
static int ag_action_10_proc(PCB_DECL);
static int ag_action_11_proc(PCB_DECL);
static int ag_action_12_proc(PCB_DECL);


static int (*const  ag_r_procs_scan[])(PCB_DECL) = {
  ag_action_1_r_proc,
  ag_action_2_r_proc,
  ag_action_3_r_proc,
  ag_action_4_r_proc
};

static int (*const  ag_s_procs_scan[])(PCB_DECL) = {
  ag_action_1_s_proc,
  ag_action_2_r_proc,
  ag_action_3_s_proc,
  ag_action_4_r_proc
};

static int (*const  ag_gt_procs_scan[])(PCB_DECL) = {
  ag_action_1_proc,
  ag_action_2_proc,
  ag_action_3_proc,
  ag_action_4_proc,
  ag_action_5_proc,
  ag_action_6_proc,
  ag_action_7_proc,
  ag_action_8_proc,
  ag_action_9_proc,
  ag_action_10_proc,
  ag_action_11_proc,
  ag_action_12_proc
};


static int ag_rns(PCB_DECL, int ag_t, int *ag_sx, int ag_snd) {
  while (1) {
    int ag_act, ag_k = ag_sbt[ag_snd], ag_lim = ag_sbt[ag_snd+1];
    int ag_p;

    while (ag_k < ag_lim && ag_tstt[ag_k] != ag_t) ag_k++;
    if (ag_k == ag_lim) break;
    ag_act = ag_astt[ag_k];
    ag_p = ag_pstt[ag_k];
    if (ag_act == ag_action_2) return ag_p;
    if (ag_act == ag_action_10 || ag_act == ag_action_11) {
      (*ag_sx)--;
      return ag_snd;
    }
    if (ag_act != ag_action_3 &&
      ag_act != ag_action_4) break;
    *ag_sx -= (ag_fl[ag_p] - 1);
    ag_snd = (PCB).ss[*ag_sx];
    ag_t = ag_ptt[ag_p];
  }
  return 0;
}

static int ag_jns(PCB_DECL, int ag_t) {
  int ag_k;

  ag_k = ag_sbt[(PCB).sn];
  while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
  while (1) {
    int ag_p = ag_pstt[ag_k];
    int ag_sd;

    switch (ag_astt[ag_k]) {
    case ag_action_2:
      (PCB).ss[(PCB).ssx] = (PCB).sn;
      return ag_p;
    case ag_action_10:
    case ag_action_11:
      return (PCB).ss[(PCB).ssx--];
    case ag_action_9:
      (PCB).ss[(PCB).ssx] = (PCB).sn;
      (PCB).ssx++;
      (PCB).sn = ag_p;
      ag_k = ag_sbt[(PCB).sn];
      while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
      continue;
    case ag_action_3:
    case ag_action_4:
      ag_sd = ag_fl[ag_p] - 1;
      if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
      else (PCB).ss[(PCB).ssx] = (PCB).sn;
      ag_t = ag_ptt[ag_p];
      ag_k = ag_sbt[(PCB).sn+1];
      while (ag_tstt[--ag_k] != ag_t);
      continue;
    case ag_action_5:
    case ag_action_6:
      if (ag_fl[ag_p]) break;
      (PCB).sn = ag_rns(PCB_POINTER, ag_ptt[ag_p],&(PCB).ssx, (PCB).sn);
      (PCB).ss[++(PCB).ssx] = (PCB).sn;
      ag_k = ag_sbt[(PCB).sn];
      while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
      continue;
    }
    break;
  }
  return 0;
}


static int ag_atx(PCB_DECL, int ag_t, int *ag_sx, int ag_snd) {
  int ag_k, ag_f;
  int ag_save_btsx = (PCB).btsx;
  int ag_flag = 1;

  while (1) {
    int ag_a;

    (PCB).bts[128 - ++(PCB).btsx] = *ag_sx;
    (PCB).ss[128 - (PCB).btsx] = (PCB).ss[*ag_sx];
    (PCB).ss[*ag_sx] = ag_snd;
    ag_k = ag_sbt[ag_snd];
    while (ag_tstt[ag_k] != ag_t && ag_tstt[ag_k]) ag_k++;
    ag_a = ag_astt[ag_k];
    if (ag_a == ag_action_2 ||
        ag_a == ag_action_3 ||
        ag_a == ag_action_10 ||
        ag_a == ag_action_11 ||
        ag_a == ag_action_1 ||
        ag_a == ag_action_4) break;
    if ((ag_a == ag_action_5 ||
        ag_a == ag_action_6) &&
        (ag_k = ag_fl[ag_f = ag_pstt[ag_k]]) == 0) {
        ag_snd = ag_rns(PCB_POINTER, ag_ptt[ag_f],ag_sx, (PCB).ss[*ag_sx]);
        (*ag_sx)++;
        continue;
    }
    if (ag_a == ag_action_9) {
      ag_snd = ag_pstt[ag_k];
      (*ag_sx)++;
      continue;
    }
    ag_flag = 0;
    break;
  }
  while ((PCB).btsx > ag_save_btsx) {
    *ag_sx = (PCB).bts[128 - (PCB).btsx];
    (PCB).ss[*ag_sx] = (PCB).ss[128 - (PCB).btsx--];
  }
  return ag_flag;
}

static int ag_tst_tkn(PCB_DECL) {
  int ag_rk, ag_sx, ag_snd;

  for (ag_rk = 0; ag_rk < (PCB).ag_lrss; ag_rk += 2) {
    ag_sx = (PCB).ag_rss[ag_rk];
    if (ag_sx > (PCB).ssx) continue;
    ag_snd = (PCB).ag_rss[ag_rk + 1];
    if (ag_sx > (PCB).ag_min_depth) continue;
    if (ag_atx(PCB_POINTER, (PCB).token_number, &ag_sx, ag_snd)) break;
  }
  return ag_rk;
}

static void ag_set_error_procs(PCB_DECL);

static void ag_auto_resynch(PCB_DECL) {
  int ag_sx;
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  if ((PCB).ag_error_depth && (PCB).ag_min_depth >= (PCB).ag_error_depth) {
    (PCB).ssx = (PCB).ag_error_depth;
    (PCB).sn = (PCB).ss[(PCB).ssx];
  }
  else {
    ag_diagnose(PCB_POINTER);
    SYNTAX_ERROR;
    if ((PCB).exit_flag != AG_RUNNING_CODE) return;
    (PCB).ag_error_depth = (PCB).ag_min_depth = 0;
    (PCB).ag_lrss = 0;
    (PCB).ss[ag_sx = (PCB).ssx] = (PCB).sn;
    (PCB).ag_min_depth = (PCB).ag_rss[(PCB).ag_lrss++] = ag_sx;
    (PCB).ag_rss[(PCB).ag_lrss++] = (PCB).sn;
    while (ag_sx && (PCB).ag_lrss < 2*128) {
      int ag_t = 0, ag_x, ag_s, ag_sxs = ag_sx;

      while (ag_sx && (ag_t = ag_ctn[2*(PCB).sn]) == 0) (PCB).sn = (PCB).ss[--ag_sx];
      if (ag_t) (PCB).sn = (PCB).ss[ag_sx -= ag_ctn[2*(PCB).sn +1]];
      else {
        if (ag_sx == 0) (PCB).sn = 0;
        ag_t = ag_ptt[0];
      }
      if ((ag_s = ag_rns(PCB_POINTER, ag_t, &ag_sx, (PCB).sn)) == 0) break;
      for (ag_x = 0; ag_x < (PCB).ag_lrss; ag_x += 2)
        if ((PCB).ag_rss[ag_x] == ag_sx + 1 && (PCB).ag_rss[ag_x+1] == ag_s) break;
      if (ag_x == (PCB).ag_lrss) {
        (PCB).ag_rss[(PCB).ag_lrss++] = ++ag_sx;
        (PCB).ag_rss[(PCB).ag_lrss++] = (PCB).sn = ag_s;
      }
      else if (ag_sx >= ag_sxs) ag_sx--;
    }
    ag_set_error_procs(PCB_POINTER);
  }
  (PCB).ssx++;
  (PCB).sn = 106;
  (PCB).ag_rk1 = (PCB).ag_lrss;
  return;
}

static int ag_action_12_proc(PCB_DECL) {
  int ag_k, ag_rk;

  (PCB).ssx--;
  if ((PCB).ag_rk1 == (PCB).ag_lrss) {
    (PCB).ag_rk1 = ag_tst_tkn(PCB_POINTER);
    (PCB).ssx++;
    if ((PCB).token_number == 5)
      {(PCB).exit_flag = AG_SYNTAX_ERROR_CODE; return 0;}
    (PCB).ag_tk1 = (PCB).token_number;
    ag_track(PCB_POINTER);
    return 0;
  }
  ag_rk = ag_tst_tkn(PCB_POINTER);
  if (ag_rk < (PCB).ag_rk1) {
    ag_k = 0;
    ag_track(PCB_POINTER);
  }
  else {
    ag_k = 1;
    ag_rk = (PCB).ag_rk1;
    (PCB).token_number = (ptparse_token_type) (PCB).ag_tk1;
  }
  (PCB).ag_min_depth = (PCB).ssx = (PCB).ag_rss[ag_rk++];
  (PCB).sn = (PCB).ss[(PCB).ssx] = (PCB).ag_rss[ag_rk];
  (PCB).sn = ag_jns(PCB_POINTER, (PCB).token_number);
  if ((PCB).ag_error_depth == 0 || (PCB).ag_error_depth > (PCB).ssx)
    (PCB).ag_error_depth = (PCB).ssx;
  if (++(PCB).ssx >= 128) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
    return 0;
  }
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ag_tmp_depth = (PCB).ag_min_depth;
  return ag_k;
}


static int ag_action_10_proc(PCB_DECL) {
  (PCB).btsx = 0, (PCB).drt = -1;
  ag_track(PCB_POINTER);
  return 0;
}

static int ag_action_11_proc(PCB_DECL) {
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(struct tokstr *) &(PCB).vs[(PCB).ssx]) = (PCB).input_value;
  (PCB).ssx--;
  ag_ra(PCB_POINTER);
  (PCB).ssx++;
  ag_track(PCB_POINTER);
  return 0;
}

static int ag_action_3_r_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).btsx = 0, (PCB).drt = -1;
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra(PCB_POINTER);
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_3_s_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).btsx = 0, (PCB).drt = -1;
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra(PCB_POINTER);
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_4_r_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  return 1;
}

static int ag_action_2_proc(PCB_DECL) {
  (PCB).btsx = 0, (PCB).drt = -1;
  if ((PCB).ssx >= 128) {
    (PCB).exit_flag = AG_STACK_ERROR_CODE;
    PARSER_STACK_OVERFLOW;
  }
  (*(struct tokstr *) &(PCB).vs[(PCB).ssx]) = (PCB).input_value;
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  ag_track(PCB_POINTER);
  return 0;
}

static int ag_action_9_proc(PCB_DECL) {
  if ((PCB).drt == -1) {
    (PCB).drt=(PCB).token_number;
    (PCB).dssx=(PCB).ssx;
    (PCB).dsn=(PCB).sn;
  }
  ag_prot(PCB_POINTER);
  (PCB).ss[(PCB).ssx] = (PCB).sn;
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_2_r_proc(PCB_DECL) {
  (PCB).ssx++;
  (PCB).sn = (PCB).ag_ap;
  return 0;
}

static int ag_action_7_proc(PCB_DECL) {
  --(PCB).ssx;
  (PCB).exit_flag = AG_SUCCESS_CODE;
  return 0;
}

static int ag_action_1_proc(PCB_DECL) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  ag_track(PCB_POINTER);
  return 0;
}

static int ag_action_1_r_proc(PCB_DECL) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  return 0;
}

static int ag_action_1_s_proc(PCB_DECL) {
  (PCB).exit_flag = AG_SUCCESS_CODE;
  return 0;
}

static int ag_action_4_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(struct tokstr *) &(PCB).vs[(PCB).ssx]) = (PCB).input_value;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else (PCB).ss[(PCB).ssx] = (PCB).sn;
  ag_track(PCB_POINTER);
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).s_procs[ag_astt[ag_t1]])(PCB_POINTER) == 0) break;
  }
  return 0;
}

static int ag_action_3_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap] - 1;
  (PCB).btsx = 0, (PCB).drt = -1;
  (*(struct tokstr *) &(PCB).vs[(PCB).ssx]) = (PCB).input_value;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else (PCB).ss[(PCB).ssx] = (PCB).sn;
  ag_track(PCB_POINTER);
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra(PCB_POINTER);
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).s_procs[ag_astt[ag_t1]])(PCB_POINTER) == 0) break;
  }
  return 0;
}

static int ag_action_8_proc(PCB_DECL) {
  ag_undo(PCB_POINTER);
  ag_auto_resynch(PCB_POINTER);
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_5_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap];
  (PCB).btsx = 0, (PCB).drt = -1;
  if (ag_sd) (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  else {
    (PCB).ss[(PCB).ssx] = (PCB).sn;
  }
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  ag_ra(PCB_POINTER);
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).r_procs[ag_astt[ag_t1]])(PCB_POINTER) == 0) break;
  }
  return (PCB).exit_flag == AG_RUNNING_CODE;
}

static int ag_action_6_proc(PCB_DECL) {
  int ag_sd = ag_fl[(PCB).ag_ap];
  (PCB).reduction_token = (ptparse_token_type) ag_ptt[(PCB).ag_ap];
  if ((PCB).drt == -1) {
    (PCB).drt=(PCB).token_number;
    (PCB).dssx=(PCB).ssx;
    (PCB).dsn=(PCB).sn;
  }
  if (ag_sd) {
    (PCB).sn = (PCB).ss[(PCB).ssx -= ag_sd];
  }
  else {
    ag_prot(PCB_POINTER);
    (PCB).vs[(PCB).ssx] = ag_null_value;
    (PCB).ss[(PCB).ssx] = (PCB).sn;
  }
  while ((PCB).exit_flag == AG_RUNNING_CODE) {
    unsigned ag_t1 = ag_sbe[(PCB).sn] + 1;
    unsigned ag_t2 = ag_sbt[(PCB).sn+1] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] < (unsigned char)(PCB).reduction_token) ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).r_procs[ag_astt[ag_t1]])(PCB_POINTER) == 0) break;
  }
  return (PCB).exit_flag == AG_RUNNING_CODE;
}


static void ag_check_depth(PCB_DECL, int ag_fl) {
  int ag_sx = (PCB).ssx - ag_fl;
  if ((PCB).ag_error_depth && ag_sx < (PCB).ag_tmp_depth) (PCB).ag_tmp_depth = ag_sx;
}

static int ag_action_3_er_proc(PCB_DECL) {
  ag_check_depth(PCB_POINTER, ag_fl[(PCB).ag_ap] - 1);
  return ag_action_4_r_proc(PCB_POINTER);
}

static int ag_action_2_e_proc(PCB_DECL) {
  ag_action_2_proc(PCB_POINTER);
  (PCB).ag_min_depth = (PCB).ag_tmp_depth;
  return 0;
}

static int ag_action_4_e_proc(PCB_DECL) {
  ag_check_depth(PCB_POINTER, ag_fl[(PCB).ag_ap] - 1);
  (PCB).ag_min_depth = (PCB).ag_tmp_depth;
  return ag_action_4_proc(PCB_POINTER);
}

static int ag_action_6_e_proc(PCB_DECL) {
  ag_check_depth(PCB_POINTER, ag_fl[(PCB).ag_ap]);
  return ag_action_6_proc(PCB_POINTER);
}

static int ag_action_11_e_proc(PCB_DECL) {
  return ag_action_10_proc(PCB_POINTER);
}

static int (*ag_r_procs_error[])(PCB_DECL) = {
  ag_action_1_r_proc,
  ag_action_2_r_proc,
  ag_action_3_er_proc,
  ag_action_3_er_proc
};

static int (*ag_s_procs_error[])(PCB_DECL) = {
  ag_action_1_s_proc,
  ag_action_2_r_proc,
  ag_action_3_er_proc,
  ag_action_3_er_proc
};

static int (*ag_gt_procs_error[])(PCB_DECL) = {
  ag_action_1_proc,
  ag_action_2_e_proc,
  ag_action_4_e_proc,
  ag_action_4_e_proc,
  ag_action_6_e_proc,
  ag_action_6_e_proc,
  ag_action_7_proc,
  ag_action_8_proc,
  ag_action_9_proc,
  ag_action_10_proc,
  ag_action_11_e_proc,
  ag_action_12_proc
};

static void ag_set_error_procs(PCB_DECL) {
  (PCB).gt_procs = ag_gt_procs_error;
  (PCB).r_procs = ag_r_procs_error;
  (PCB).s_procs = ag_s_procs_error;
}


void init_ptparse(ptparse_pcb_type *PCB_POINTER) {
  unsigned ag_t1;
  ag_t1 = 0;
  (PCB).gt_procs = ag_gt_procs_scan;
  (PCB).r_procs = ag_r_procs_scan;
  (PCB).s_procs = ag_s_procs_scan;
  (PCB).ag_error_depth = (PCB).ag_min_depth = (PCB).ag_tmp_depth = 0;
  (PCB).ag_resynch_active = 0;
  (PCB).ss[0] = (PCB).sn = (PCB).ssx = 0;
  (PCB).exit_flag = AG_RUNNING_CODE;
  (PCB).line = FIRST_LINE;
  (PCB).column = FIRST_COLUMN;
  (PCB).btsx = 0, (PCB).drt = -1;
  while (ag_tstt[ag_t1] == 0) {
    (PCB).ag_ap = ag_pstt[ag_t1];
    (*(PCB).gt_procs[ag_astt[ag_t1]])((PCB_TYPE *)PCB_POINTER);
    ag_t1 = ag_sbt[(PCB).sn];
  }
}

void ptparse(ptparse_pcb_type *PCB_POINTER) {
  (PCB).token_number = (ptparse_token_type) AG_TCV((PCB).input_code);
  while (1) {
    unsigned ag_t1 = ag_sbt[(PCB).sn];
    unsigned ag_t2 = ag_sbe[(PCB).sn] - 1;
    do {
      unsigned ag_tx = (ag_t1 + ag_t2)/2;
      if (ag_tstt[ag_tx] > (unsigned char)(PCB).token_number)
        ag_t1 = ag_tx + 1;
      else ag_t2 = ag_tx;
    } while (ag_t1 < ag_t2);
    if (ag_tstt[ag_t1] != (unsigned char)(PCB).token_number)
      ag_t1 = ag_sbe[(PCB).sn];
    (PCB).ag_ap = ag_pstt[ag_t1];
    if ((*(PCB).gt_procs[ag_astt[ag_t1]])((PCB_TYPE *)PCB_POINTER) == 0) break;
  }
}


