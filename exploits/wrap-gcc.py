#!/usr/bin/env python
import fcntl
import getpass
import json
import os
import pexpect
import shutil
import subprocess
import sys
import tempfile
import time

LOGFILE = 'exploit.log'
LOGDIR = '/tmp/exploit-log/'
FILESDIR = '/tmp/exploit-log/files/'
DEBUG = False
MAX_CONTENT_SIZE = 1024 * 1024 # max number of bytes of content to log for scripts - 1MB, currently

"""
Saves a copy of a file to the log directory, diffing if possible and diff is True
Returns the path to the file in the log folder
"""
def log_file(path, diff=False):
    # construct path for file (removing leading slash from path)
    # XXX: make sure trailing slash is only there once
    if path[0] == '/':
        log_path = FILESDIR + path[1:] + '/'
    else:
        log_path = FILESDIR + path + '/'

    # check if directory exists (no need to worry about race conditions,
    # because only one file copy is allowed at once
    #XXX: need to check if dir?
    if not os.path.exists(log_path):
        os.makedirs(log_path)

    return make_base(path, log_path)

"""
Makes a copy of 'path' as a new base copy in the 'log_path' directory
Returns path to new file, or None on error.
"""
def make_base(path, log_path):
    # copy logfile with time suffix
    copy_time = time.time()

    # create new file name
    dest = log_path + 'base.' + str(copy_time)
    # copy in with new name (TODO: error check on name)
    try:
        shutil.copy(path, dest)
        shutil.copy(dest, log_path + '.current')

    except Exception, e:
        if DEBUG:
            print "failed to copy file"
            print e
        return None

    # return dest, if all suceeeded
    return dest

def log_obj(obj):
    # add timestamp and turn to string
    obj['_timestamp'] = time.time()
    string = json.dumps(obj)

    try:
        with open(LOGDIR + LOGFILE, "a+") as logfile:
            # lock file. lock should be released when file is closed
            # XXX: should this be nonblocking?
            fcntl.flock(logfile, fcntl.LOCK_EX)

            try:
                logfile.write("%s\n" % string)
            except:
                pass
    except Exception, e:
        if DEBUG:
            print "failed to log object"
            print e
        pass

"""
Runs a program, recording a script of execution in the log
"""
class ScriptWrapper:
    def __init__(self, progName, extraData = None, realProgPath = None):
        # if no real path is found, find it with which
        if realProgPath is None:
            realProgPath = self.findRealProgPath(progName)
            if realProgPath is None:
                print "%s: command not found" % progName
                exit()

        # set instance variables
        self.progName = progName
        self.realProgPath = realProgPath
        self.extraData = extraData

    def run(self):
        # gen rand file name for pexpect logfile
        temp = tempfile.NamedTemporaryFile(delete=False)
        os.chown(temp.name, os.geteuid(), os.getegid())

        # run program, modifying argv to go to real program
        sys.argv[0] = self.realProgPath

        # build command
        command = ' '.join(sys.argv)

        start_time = time.time()
        p = pexpect.spawn(command)
        p.logfile = temp

        # removed because unnecessary
        #global global_pexpect_instance
        #global_pexpect_instance = p
        #signal.signal(signal.SIGWINCH, sigwinch_passthrough)

        try:
            p.interact()

        # for I/O problems on quit
        except OSError:
            pass

        end_time = time.time()

        # read in logfile
        f = open(temp.name)
        content = f.read()
        temp.close()

        p.close()

        # cap size of content
        content = content[:MAX_CONTENT_SIZE]

        # create object to be logged
        obj = {'_type':'wrapper', 'prog': self.progName, 'cmd': command, 'exit_code': p.exitstatus, 'start_time':start_time, 'end_time':end_time, 'content':content, 'cwd':os.getcwd(), 'username': getpass.getuser()}

        # add extra data if provided
        if self.extraData is not None:
            obj.update(self.extraData)

        # write log
        log_obj(obj)

    def findRealProgPath(self, progName):
        try:
            # call which on program name
            output = subprocess.check_output(['which', '-a', progName])
            lines = output.split('\n')
            if len(lines) < 1:
                return None

            cmd = lines[0]

            # if new path found, return it
            return cmd

        # if call failed, fail
        except:
            return None


if __name__ == '__main__':
    # create dict to hold data for script wrapper
    data = {}
    data['files'] = []

    # log files compiled
    for arg in sys.argv:
        arg_path = os.path.abspath(arg.lower())

        # if argument is a .c or .h file, log it
        if (arg_path.endswith('.c') or arg_path.endswith('.h')) and os.path.isfile(arg_path):
            dest_path = log_file(arg_path, diff=True)

            # add file to data
            data['files'].append({'name':arg, 'path': arg_path, 'dest_path':dest_path})

    # record script of output
    wrapper = ScriptWrapper("gcc", data)
    wrapper.run()

